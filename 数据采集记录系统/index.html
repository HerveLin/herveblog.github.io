<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.8.0">

    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->

    

    
        <meta name="description" content="&amp;emsp;&amp;emsp;又是一年一度的电子设计大赛了，去年什么奖都没拿，完全不知道评委是什么眼光。今年大二了，可以参加高年级组的题目，我们选了一个物联网主题的题目，设计一个数据采集系统。
&amp;emsp;&amp;emsp;本次手机APP是采用面向对象的编程语言（java）和面向对象的编程工具（eclipse）">
    

    <!--Author-->
    
        <meta name="author" content="Herve Lin">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="数据采集记录系统">
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="&amp;emsp;&amp;emsp;又是一年一度的电子设计大赛了，去年什么奖都没拿，完全不知道评委是什么眼光。今年大二了，可以参加高年级组的题目，我们选了一个物联网主题的题目，设计一个数据采集系统。
&amp;emsp;&amp;emsp;本次手机APP是采用面向对象的编程语言（java）和面向对象的编程工具（eclipse）">
    

    <!--Open Graph Site Name-->
        <meta property="og:site_name" content="Herve&#39;s blog">

    <!--Type page-->
    
        <meta property="og:type" content="article">
    

    <!--Page Cover-->
    
    
        <meta property="og:image" content="http://yoursite.com/img/home-bg.jpg">
    

        <meta name="twitter:card" content="summary_large_image">

    

    
        <meta name="twitter:image" content="http://yoursite.com/img/home-bg.jpg">
    

    <!-- Title -->
    
    <title>数据采集记录系统 - Herve&#39;s blog</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet">

    <!-- Google Analytics -->
    


    <!-- favicon --><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</head>


<body>

    <!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">MENU</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/klugjo/hexo-theme-clean-blog">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>数据采集记录系统</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2016-05-11
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/tags/电子设计大赛/">#电子设计大赛</a> <a href="/tags/单片机/">#单片机</a>


                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <p>&emsp;&emsp;又是一年一度的电子设计大赛了，去年什么奖都没拿，完全不知道评委是什么眼光。今年大二了，可以参加高年级组的题目，我们选了一个物联网主题的题目，设计一个数据采集系统。</p>
<p>&emsp;&emsp;本次手机APP是采用面向对象的编程语言（java）和面向对象的编程工具（eclipse）开发出来的android app。app可以自动识别经过加密压缩的数据短信，并将解码后的数据完整的写进数据库，并且可以将数据库数据按地点、年月日进行查询，根据选择画出数据图表。</p>
<p>&emsp;&emsp;涉及的内容有：短信的读取、数据解码、litepal数据库框架、数据短信的防重复读写处理、野外数据多地点检测、achartengine作图库、动画特效。</p>
<h5 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h5><p>&emsp;STM32,PM2.5,GSM,android开发,SQL,litepal数据库,achartengine。</p>
<h2 id="一、设计任务和要求"><a href="#一、设计任务和要求" class="headerlink" title="一、设计任务和要求"></a>一、设计任务和要求</h2><h3 id="1、任务"><a href="#1、任务" class="headerlink" title="1、任务"></a>1、任务</h3><p>&emsp;&emsp;野外一般没有Wifi，却有GSM网络的覆盖，因此需要设计一个通过GSM网络采集数据的系统。将下位机采集到的数据，通过GSM无线通讯技术，传输到手机内显示，并实现保存和分析功能。</p>
<div align="center"><img src="/数据采集记录系统/figure.1.JPG" alt="图1"><br>系统示意图</div>

<h3 id="2、要求"><a href="#2、要求" class="headerlink" title="2、要求"></a>2、要求</h3><h4 id="A-基本要求"><a href="#A-基本要求" class="headerlink" title="A. 基本要求"></a>A. 基本要求</h4><p>&emsp;&emsp;（1）下位机通过I/O口和温度探测器相连，温度设定范围为5～50℃，最小区分度为0.1℃，标定误差温度≤0.1℃。<br>&emsp;&emsp;（2）用十进制数码管显示环境的实际温度。<br>&emsp;&emsp;（3）能够每小时缓存一组温度数据。<br>&emsp;&emsp;（4）能够每5个小时定时通过GSM模块、以短信的方式集中将5组温度数据发送给指定手机保存。</p>
<h4 id="B-发挥部分"><a href="#B-发挥部分" class="headerlink" title="B. 发挥部分"></a>B. 发挥部分</h4><p>&emsp;&emsp;（1）在手机端自动阅读短信并能保存温度数据进行统计分析。<br>&emsp;&emsp;（2）尝试建立数据服务器，下位机用GPRS的形式将数据传给服务器，手机能用APP程序，阅读和统计分析数据。以上功能完成1项即可。<br>&emsp;&emsp;（3）完善手机APP界面。 </p>
<h2 id="二、总体方案"><a href="#二、总体方案" class="headerlink" title="二、总体方案"></a>二、总体方案</h2><h3 id="2-1-方案的描述"><a href="#2-1-方案的描述" class="headerlink" title="2.1 方案的描述"></a>2.1 方案的描述</h3><p>&emsp;&emsp;经过构思，我们的系统决定使用单片机加功能模块完成，为了更加符合野外数据采集的需求，我们还加入了湿度，PM2.5的测量，以及设计了SD卡基于FAT32文件系统的数据储存系统，用以应对不稳定的野外数据传输环境。<br>&emsp;&emsp;因为GSM对外的数据发送并不是稳定的，例如SIM卡欠费来不及充值，强磁信号干扰，服务器不稳定，都会导致数据断流，这个时候把数据存一份在SD卡中的LOG文件，是十分稳定可靠的，同时也可以分析系统运行状态，利于设备的维护。<br>&emsp;&emsp;PM2.5测量的加入是为了响应时代的潮流，近几年，中国的空气状况频繁上新闻头条，PM2.5就是一个关键词，重要的空气质量指标，连小孩老人都关注。所以，野外数据采集系统当然需要空气质量的检测，所以，我们加入了PM2.5检测。</p>
<div align="center"><img src="/数据采集记录系统/figure.2.JPG" alt="图2"><br></div>

<h3 id="2-2-方案的比较分析"><a href="#2-2-方案的比较分析" class="headerlink" title="2.2 方案的比较分析"></a>2.2 方案的比较分析</h3><p>&emsp;&emsp;(1)    单片机MCU选型<br>&emsp;&emsp;&emsp;市面上的单片机真的有无数种，但是题目一出来我就决定使用意法半导体的STM32F103系单片机:<br>&emsp;&emsp;&emsp;1.    51单片机<br>&emsp;&emsp;&emsp;&emsp;51单片机是全中国大学生用到烂的一款单片机，以下是51单片机的普遍配置：</p>
<font face="黑体" color="black" size="3"><br>&emsp;&emsp;&emsp;&emsp;•8位CPU•4kbytes程序存储器(ROM) (52为8K)<br>&emsp;&emsp;&emsp;&emsp;•128bytes的数据存储器(RAM) （52有256bytes的RAM）<br>&emsp;&emsp;&emsp;&emsp;•32条I/O口线•111条指令，大部分为单字节指令<br>&emsp;&emsp;&emsp;&emsp;•21个专用寄存器<br>&emsp;&emsp;&emsp;&emsp;•2个可编程定时/计数器•5个中断源，2个优先级（52有6个）<br>&emsp;&emsp;&emsp;&emsp;•一个全双工串行通信口<br>&emsp;&emsp;&emsp;&emsp;•外部数据存储器寻址空间为64kB<br>&emsp;&emsp;&emsp;&emsp;•外部程序存储器寻址空间为64kB<br>&emsp;&emsp;&emsp;&emsp;•逻辑操作位寻址功能•双列直插40PinDIP封装<br>&emsp;&emsp;&emsp;&emsp;•单一+5V电源供电<br>&emsp;&emsp;&emsp;&emsp;CPU：由运算和控制逻辑组成，同时还包括中断系统和部分外部特殊功能寄存器；<br>&emsp;&emsp;&emsp;&emsp;RAM：用以存放可以读写的数据，如运算的中间结果、最终结果以及欲显示的数据；<br>&emsp;&emsp;&emsp;&emsp;ROM：用以存放程序、一些原始数据和表格；<br>&emsp;&emsp;&emsp;&emsp;I/O口：四个8位并行I/O口，既可用作输入，也可用作输出<br>&emsp;&emsp;&emsp;&emsp;T/C：两个定时/记数器，既可以工作在定时模式，也可以工作在记数模式；<br>&emsp;&emsp;&emsp;&emsp;五个中断源的中断控制系统；<br>&emsp;&emsp;&emsp;&emsp;一个全双工UART（通用异步接收发送器）的串行I/O口。<br>&emsp;&emsp;&emsp;&emsp;片内振荡器和时钟产生电路，石英晶体和微调电容需要外接。最佳振荡频率为6M—12M。<br></font><br>&emsp;&emsp;&emsp;&emsp;首先51（52）单片机的外设就很吝啬，只有一个硬件UART，但是在我们的系统需要两个UART串口（GSM模块和粉尘检测模块），一个SPI（SD卡），一个I2C（温度湿度模块），显然不足，当然，国产的51单片机厂商STC已经给51拓展的很强大了，但是满足外设需求的高端系列芯片一片售价是4-6块钱，我们选用的ARM单片机才6块钱，性价比首先就打败了51，其次，51的内存才128B（52是256B），STC的高端芯片是有2KB的，但也是不足的，打个比方，GSM的串口需要的缓存BUFFER我们开辟了512B，<br>&emsp;&emsp;&emsp;&emsp;USB的BUFFER是512B，LCD的显存1KB（由于LCD选用了串行通信，所以内置缓存不能使用，是LCD的硬件BUG），还没举例完，51的内存显然是不够的，后面还更有传感器数据的FIFO队列需要大量内存。所以，我们淘汰了51单片机的MCU方案。<br><br>&emsp;&emsp;&emsp;2.    Arduino<br>Arduino是在世界范围都十分流行的一款单片机，有基于AVR的Arduino，有基于STM的Arduino，高端的Arduino是能满足我们的资源需求。但是，成本高，而且，Arduino最终还是一块开发板，不适合我们做集成度高的作品。再者，Arduino的软件集成度太高，函数都封装在SDK里面，但是我们系统的模块通信之间的协议的低层是需要一定的调整的。总之，用Arduino太不自由，不适合我们这些高端的开发者，淘汰掉。<br><br>&emsp;&emsp;&emsp;3.    ARM 单片机<br>ARM是近几年的关键词，ARM嵌入式已经占到了非常大的份额，看看现在智能手机的普及率，吓死人。ARM普及了，有什么好处呢，成本下降了，人人都可以用了。我们选用的就是意法半导体的STM32F103C8T6，散件买也只要6元一片，十分便宜，接下来介绍下他的配置，从它的DATASHEET可以看到：<br><br><div align="center"><img src="/数据采集记录系统/figure.3.JPG" alt="图3"><br></div><br><br><div align="center"><img src="/数据采集记录系统/figure.4.JPG" alt="图4"><br></div><br><br>&emsp;&emsp;&emsp;&emsp;首先他的运行频率是72MHz（默认），而且是ARM的指令集，大部分指令的机器周期才1，而51频率最多12MHz（普遍），而且机器周期是12，这个运算速度差距十分明显。后面我们系统需要用到的短信压缩算法（哈夫曼编码，强哥编码），卡尔曼滤波算法，浮点数据的标定，都需要大量的运算，显然选用它是十分恰当的。同时，它内置USB，CRC硬件处理，简直就是对系统维护和SD卡的通信的神器。它的内存有20KB，2个硬件SPI，2个硬件I2C，3个USART，37个IO，真的绰绰有余。它还有DMA，对于这么频繁的数据通信的设备，又是一个致命的优点。最后要介绍的是他的看门狗功能，野外数据采集是对系统的自稳定要求非常高的项目，他有IWDG和WWDG两种看门狗功能，长期的运行，环境的恶劣，设备是随时可能跑飞，当机。开启了看门狗，这些情况真的不算什么，能在问题发生时自复位，之后对系统的故障记录，以及数据的保护都是简单的事。<br><br>## 三、单元电路设计<br><br>### 3.1 硬件框架<br>#### 3.1.1 原理图<br><br><div align="center"><img src="/数据采集记录系统/figure.5.JPG" alt="图5"><br></div><br><br>详细原理图（绘于OrCAD）<br>PART1(STM32F103C8T6):<br><br><div align="center"><img src="/数据采集记录系统/figure.6.JPG" alt="图6"><br></div><br><br>PART2(LCD12864):<br><br><div align="center"><img src="/数据采集记录系统/figure.7.JPG" alt="图7"><br></div><br><br>PART3(电源部分):<br><br><div align="center"><img src="/数据采集记录系统/figure.8.JPG" alt="图8"><br></div><br><br>PART4(GSM、MICROSD):<br><br><div align="center"><img src="/数据采集记录系统/figure.9.JPG" alt="图9"><br></div><br><br>PART5(传感器):<br><br><div align="center"><img src="/数据采集记录系统/figure.10.JPG" alt="图10"><br></div><br><br>PART6(按键、LED指示灯):<br><br><div align="center"><img src="/数据采集记录系统/figure.11.JPG" alt="图11"><br></div><br><br>#### 3.1.2 PCB图<br><br><div align="center"><img src="/数据采集记录系统/figure.12.JPG" alt="图12"><br></div><br><br>### 3.2 开关电源的设计<br>&emsp;&emsp;在本系统中，单片机供电需求是3.3v直流电，温湿度传感器供电需求是3.3v直流电，SD卡供电需求是3.3v直流电，LCD显示屏供电要求是3.3v直流电。所以我们决定用低压差线性稳压器（LDO）把USB或锂电池减压的到3.3v。而GSM模块和粉尘传感器是5v供电，直接由USB或者锂电池BOOST升压得到。经过选型，我们的LDO芯片选用德州仪器的TPS79333，输入电压为3.50V-5.24V，输出电压3.3V，最大输出电流0.2A，效率62%，工作环境-40 ~ 125℃。<br><br>### 3.3 传感器的设计<br>#### 3.3.1 温湿度传感器HTU21D<br><br>&emsp;&emsp;温湿度传感器我们选用了一枚十分优秀的芯片：HTU21D，性价比非常高（散件10元一片）。要知道同等性能的瑞士SHT15是要60元一片的。<br><br>##### 3.3.1.1 I2C通信协议<br><br>&emsp;&emsp;HTU21D是使用了标准的I2C协议通信，I2C（Inter－Integrated Circuit）总线是由PHILIPS公司开发的两线式串行总线，用于连接微控制器及其外围设备。是微电子通信控制领域广泛采用的一种总线标准。它是同步通信的一种特殊形式，具有接口线少，控制方式简单，器件封装形式小，通信速率较高等优点。I2C 总线支持任何IC 生产过程(CMOS、双极性）。通过串行数据（SDA）线和串行时钟 （SCL）线在连接到总线的器件间传递信息。每个器件都有一个唯一的地址识别（无论是微控制器——MCU、LCD 驱动器、存储器或键盘接口），而且都可以作为一个发送器或接收器（由器件的功能决定）。LCD 驱动器只能作为接收器，而存储器则既可以接收又可以发送数据。除了发送器和接收器外，器件在执行数据传输时也可以被看作是主机或从机。主机是初始化总线的数据传输并产生允许传输的时钟信号的器件。此时，任何被寻址的器件都被认为是从机。<br><br><div align="center"><img src="/数据采集记录系统/figure.13.JPG" alt="图13"><br></div><br><br>##### 3.3.1.2 温度测量的性能<br><br><div align="center"><img src="/数据采集记录系统/figure.14.JPG" alt="图14"><br></div><br><br>&emsp;&emsp;我们题目的要求是区分度0.1℃，温度检测范围是5-50℃，标定误差是小于等于0.1℃。当我们这款传感器采样分辨率设定为14位时（默认），它的温度分辨率是0.01摄氏度，采样时间典型值是44毫秒，这个采样时间完全足够支撑滤波的性能。关于标定，我们再来看看它的误差线性：<br><br><div align="center"><img src="/数据采集记录系统/figure.15.JPG" alt="图15"><br></div><br><br>&emsp;&emsp;可以看到在5-50摄氏度的误差线性是十分感人的。经过简单的二次标定，轻易达到题目要求的标定误差范围内。<br><br>#### 3.3.2 PM2.5传感器GP2Y1051AU0F<br><br>&emsp;&emsp;由于成本的限制，我们选择了一个很低端的粉尘传感器：GP2Y1051AU0F。GP2Y1051AU0F是灰尘（粉尘）传感器由光学传感系统一个红外发光二极管（IRED）和光电子晶体管是对角布置在该装置中组成的。它是通过检测空气中尘埃的反射光计算粉尘的浓度。尤其是它可以有效地检测到非常细的颗粒像香烟烟雾。此外，它可以从房屋灰尘烟雾区别通过输出电压的脉冲模式。<br><br>##### 3.3.2.1 UART通信协议<br><br>&emsp;&emsp;通用异步收发传输器（Universal Asynchronous Receiver/Transmitter)，通常称作UART，是一种异步收发传输器，是电脑硬件的一部分。将资料由串行通信与并行通信间作传输转换，作为并行输入成为串行输出的芯片，通常集成于其他通讯接口的连结上。<br>具体实物表现为独立的模块化芯片，或作为集成于微处理器中的周边设备。一般是RS-232C规格的，类似Maxim的MAX232之类的标准信号幅度变换芯片进行搭配，作为连接外部设备的接口。在UART上追加同步方式的序列信号变换电路的产品，被称为USART(Universal Synchronous Asynchronous Receiver Transmitter)。<br>GP2Y1051AU0F是单向通信，所以只使用TXD线与MCU通信，它的波特率是2400.<br><br>##### 3.3.2.2 反馈数据解析<br><br><div align="center"><img src="/数据采集记录系统/figure.16.JPG" alt="图16"><br></div><br><br>&emsp;&emsp;单片机接收方面，是使用串口接收中断实现对数据的缓存，之后把缓存的数据通过校验，由电压值换算成PM2.5值，送入滤波的FIFO队列，在经过卡尔曼滤波，送入待输送到手机和SD卡的FIFO队列。这款传感器性能还是比较差的，噪音严重，经过我们细心研究，卡尔曼滤波很好的应付了这款传感器硬件的缺陷。<br><br>### 3.4 显示模块的设计<br><br>&emsp;&emsp;显示模块我们没有选择题目要求的数码管，数码管玩来玩去也就一个扫描显示，没意思，十分局限我们的发挥。所以我们选择了一块液晶显示屏LCD12864，自带中文字库，十分方便，绘图画点，做动画什么都可以。<br>LCD12864默认是5v，在修改了液晶模块的升压电路后，适应了我们3.3v供电，由于IO资源很紧张，我们使用了串行通信，做个比较，如果使用并行是需要RS、R/W、E、DB0~7、RST一共12个IO口来控制，而使用串行只需要CS、SID、CLK、RST &emsp;&emsp;一共4个IO。只是牺牲了速度，所幸我们的设备不需要高的刷新率。同时使用串行有个BUG，就是液晶的主控芯片ST7920在串行下的读DDRAM指令无效，所以要在单片机开辟一个1KB（128<em>64/8）的显存才能实现在LCD上任意画点。<br>我们在LCD上实现了菜单系统，有了十分不错的交互，通过按键打开多级菜单可以进行对设备的操控，设置和调试。<br><br>### 3.5 GSM模块的设计<br><br>GSM模块我们选用了SIMCOM公司的SIM800L，这个模块是我十分喜欢的一块GSM模块，第一它功耗很低，第二它体积十分小（一枚一元硬币那么大），第三是它采用主流的AT指令，调试很简单，不懂的看手册，找百度一定就可以解决。<br><br>#### 3.5.1 SIM800L简介<br><br>&emsp;&emsp;SIM800L模块可支持4频GSM/GPRS，工作的频段为：GSM850、EGSM900、DCS1800和PCS1900MHz。<br>&emsp;&emsp;模块的尺寸只有15.8</em>17.8*2.4 mm，几乎可以满足所有用户应用中的对空间尺寸的要求。<br>&emsp;&emsp;模块和用户的物理接口为88个的LGA焊盘，提供了模块的所有硬件接口。<br>&emsp;&emsp;最多可支持50个按键。<br>&emsp;&emsp;一路全功能串口，可根据需要配置成两个独立的串口。<br>&emsp;&emsp;一路USB接口，可模拟出一路串口，便于客户调试、下载软件。<br>&emsp;&emsp;两路音频接口，包含麦克风输入和受话器输出。<br>&emsp;&emsp;可编程的通用输入输出接口（GPIO）。一路SIM卡接口支持FM功能PWM功能引脚。<br>&emsp;&emsp;SIM800L采用省电技术设计，在休眠模式下耗电流低至0.7毫安。<br>&emsp;&emsp;SIM800L是支持编程的，但是我们用的是模块，所以IO已经封装好，没有外留。不然的话完可以做成DTU，单片机也省了。<br><br>#### 3.5.2 SIM800L与MCU通信方式<br><br>&emsp;&emsp;SIM800L使用USART串口与MCU通信，波特率默认是9600，可以进行设置，MCU同样是用串口中断去缓存来之SIM800L的指令。SIM800L使用的是一套通用的AT指令，待发送数据的FIFO队列在发送时，通过单片机，将数据进行压缩后（哈夫曼编码或强哥编码），按PDU短信的规则进行编码，用AT指令发送给SIM800L模块，让它去给上位手机发送短信。<br><br><font face="黑体" color="black" size="3"><br>&emsp;&emsp;&emsp;&emsp;常用AT指令<br>&emsp;&emsp;AT指令        功能<br>&emsp;&emsp;AT命令        设置不回显命令<br>&emsp;&emsp;ATEO        查询网络是否已经注册<br>&emsp;&emsp;AT+CREG?    设置短信到达提醒方式<br>&emsp;&emsp;AT+CPMS=    设置短信存储在模块<br>&emsp;&emsp;AT+CPBS=SM    设置电话薄位置SIM卡<br>&emsp;&emsp;AT+CMGF=0/1    设置短信模式。0：PDU 1：TEXT<br>&emsp;&emsp;AT+CMGS=    发送新短信<br>&emsp;&emsp;AT+CMGSS=1    发送存在SIM卡的短信<br>&emsp;&emsp;AT+CMSR=1    读取模块1号位置短信<br>&emsp;&emsp;AT+CMGD=1    删除模块1号位置<br>&emsp;&emsp;AT+CPBR=1    读取卡1号位置电话号码<br>&emsp;&emsp;ATH            挂断电话<br></font>

<h3 id="3-6-SD卡模块的设计"><a href="#3-6-SD卡模块的设计" class="headerlink" title="3.6 SD卡模块的设计"></a>3.6 SD卡模块的设计</h3><h4 id="3-6-1-SD卡硬件连接"><a href="#3-6-1-SD卡硬件连接" class="headerlink" title="3.6.1 SD卡硬件连接"></a>3.6.1 SD卡硬件连接</h4><p>&emsp;&emsp;SD卡的硬件连接非常简单，只用给信号线加上上拉电阻，及给供电加上去耦电容即可。SD内部是一个有六个寄存器的主控，主控对储存区进行管理，而外部MCU对主控通过SDIO或者SPI通信。</p>
<div align="center"><img src="/数据采集记录系统/figure.17.JPG" alt="图17"><br></div>

<p>&emsp;&emsp;我们选用的是MICROSD卡以及SPI通信，SPI比SDIO速度会慢很多，但是我们这个设备并不需要高速的数据传输，不像图像数据储存，只是简单的文字数据储存。再者，我们选用的STM32F103C8T6并不支持SDIO。</p>
<h4 id="3-6-2-SPI通信协议"><a href="#3-6-2-SPI通信协议" class="headerlink" title="3.6.2 SPI通信协议"></a>3.6.2 SPI通信协议</h4><p>&emsp;&emsp;SPI的通信原理很简单，它以主从方式工作，这种模式通常有一个主设备和一个或多个从设备，需要至少4根线，事实上3根也可以（单向传输时）。也是所有基于SPI的设备共有的，它们是SDI（数据输入）、SDO（数据输出）、SCLK（时钟）、CS（片选）。</p>
<p>&emsp;&emsp;（1）SDO – 主设备数据输出，从设备数据输入；<br>&emsp;&emsp;（2）SDI – 主设备数据输入，从设备数据输出；<br>&emsp;&emsp;（3）SCLK – 时钟信号，由主设备产生；<br>&emsp;&emsp;（4）CS – 从设备使能信号，由主设备控制。</p>
<p>&emsp;&emsp;其中，CS是控制芯片是否被选中的，也就是说只有片选信号为预先规定的使能信号时（高电位或低电位），对此芯片的操作才有效。这就允许在同一总线上连接多个SPI设备成为可能。</p>
<p>&emsp;&emsp;接下来就负责通讯的3根线了。通讯是通过数据交换完成的，这里先要知道SPI是串行通讯协议，也就是说数据是一位一位的传输的。这就是SCLK时钟线存在的原因，由SCLK提供时钟脉冲，SDI，SDO则基于此脉冲完成数据传输。数据输出通过 SDO线，数据在时钟上升沿或下降沿时改变，在紧接着的下降沿或上升沿被读取。完成一位数据传输，输入也使用同样原理。这样，在至少8次时钟信号的改变（上沿和下沿为一次），就可以完成8位数据的传输。</p>
<p>&emsp;&emsp;要注意的是，SCLK信号线只由主设备控制，从设备不能控制信号线。同样，在一个基于SPI的设备中，至少有一个主控设备。这样传输的特点：这样的传输方式有一个优点，与普通的串行通讯不同，普通的串行通讯一次连续传送至少8位数据，而SPI允许数据一位一位的传送，甚至允许暂停，因为SCLK时钟线由主控设备控制，当没有时钟跳变时，从设备不采集或传送数据。也就是说，主设备通过对SCLK时钟线的控制可以完成对通讯的控制。SPI还是一个数据交换协议：因为SPI的数据输入和输出线独立，所以允许同时完成数据的输入和输出。不同的SPI设备的实现方式不尽相同，主要是数据改变和采集的时间不同，在时钟信号上沿或下沿采集有不同定义，具体请参考相关器件的文档。</p>
<p>&emsp;&emsp;最后，SPI接口的一个缺点：没有指定的流控制，没有应答机制确认是否接收到数据。</p>
<p>&emsp;&emsp;SPI的片选可以扩充选择16个外设,这时PCS输出=NPCS,说NPCS0~3接4-16译码器,这个译码器是需要外接4-16译码器，译码器的输入为NPCS0~3，输出用于16个外设的选择。</p>
<h4 id="3-6-3-SD协议2-0"><a href="#3-6-3-SD协议2-0" class="headerlink" title="3.6.3 SD协议2.0"></a>3.6.3 SD协议2.0</h4><p>&emsp;&emsp;我们用的是SDHC卡，所以需要参考SD协议2.0以上。2.0协议主要增加了对大容量SD卡（大于2GB）的支持，定义了4个速度等级。同时在SD协议上可以看到它的一条命令是6字节，所以SPI的底层驱动是比较复杂的，需要写很多的算法，但是我们享受这种随心所遇操控设备的感觉。</p>
<div align="center"><img src="/数据采集记录系统/figure.18.JPG" alt="图18"><br></div>

<p>&emsp;&emsp;SPI的切换是在SD卡的初始化的时候完成的，切换为SPI通信后，只要不断电，就不能改变。SD卡的初始化是挺复杂的，从SD协议2.0有较长的篇幅讲解：</p>
<div align="center"><img src="/数据采集记录系统/figure.19.JPG" alt="图19"><br></div>

<h3 id="3-7-交互部分的设计"><a href="#3-7-交互部分的设计" class="headerlink" title="3.7 交互部分的设计"></a>3.7 交互部分的设计</h3><h4 id="3-7-1-LED的设计"><a href="#3-7-1-LED的设计" class="headerlink" title="3.7.1 LED的设计"></a>3.7.1 LED的设计</h4><p>&emsp;&emsp;LED我们选择用单片机的IO口直接驱动，STM32的GPIO可以提供最多30MA的电流，绰绰有余了，如果选用51，AVR还得加上拉或者下拉电阻，很麻烦。</p>
<p>&emsp;&emsp;我们使用了两颗LED，一颗绿一颗红，下面介绍下灯语的设计：</p>
<font face="黑体" color="black" size="3"><br>&emsp;&emsp;状态            红灯    绿灯<br>&emsp;&emsp;空闲            灭        亮<br>&emsp;&emsp;数据写入FIFO    亮        灭<br>&emsp;&emsp;时间获取异常    亮0.5s    灭<br>&emsp;&emsp;时间获取成功    灭        亮0.5s<br>&emsp;&emsp;发送短信        亮        亮<br>&emsp;&emsp;SD卡读写        亮      亮<br></font>

<p>3.7.2 按键的设计</p>
<p>&emsp;&emsp;我们的键盘采取了四个外部中断，单片机的IO口设置为上拉输入，当按下按键，IO口被下拉到地，触法中断，再经过软件滤波，引发按键事件。我们设定了菜单键，返回键，方向上键，方向下键。 </p>
<h2 id="第四章、设备程序设计"><a href="#第四章、设备程序设计" class="headerlink" title="第四章、设备程序设计"></a>第四章、设备程序设计</h2><h3 id="4-1-系统框架"><a href="#4-1-系统框架" class="headerlink" title="4.1 系统框架"></a>4.1 系统框架</h3><p>&emsp;&emsp;软件流程如下:</p>
<div align="center"><img src="/数据采集记录系统/figure.20.JPG" alt="图20"><br></div>

<h3 id="4-2-系统初始化"><a href="#4-2-系统初始化" class="headerlink" title="4.2 系统初始化"></a>4.2 系统初始化</h3><p>&emsp;&emsp;（1）    系统时钟初始化：设置为HSE，由外部8MHz晶振产生系统时钟源，PLL9倍频为72MHz                作为系统时钟。<br>&emsp;&emsp;（2）    Systick初始化：打开系统滴答，提供准确的1us定时，为后面精确的延时函数服务。<br>&emsp;&emsp;（3）    Lcd12864初始化：SID，CLK，CS和RST的IO口设置为推挽输出，给LCD发出复位指令，并且清屏，显示出系统的初始化进度。<br>&emsp;&emsp;（4）    LED、键盘初始化：LED的IO口设置为推挽输出，键盘IO设置为上拉输入。<br>&emsp;&emsp;（5）    芯片内部温度传感器初始化。<br>&emsp;&emsp;（6）    HTU21D初始化：初始化I2C，开始采样。<br>&emsp;&emsp;（7）    GP2Y初始化：串口1初始化。<br>&emsp;&emsp;（8）    SD初始化：SPI1初始化，给SD发出初始化指令。<br>&emsp;&emsp;（9）    SIM800L初始化：串口3初始化，检查信号，网络连接状况，等待信息功能就绪。<br>&emsp;&emsp;（10）    GPRS联网获取当前UTC时间：连接服务器获取时间，并装载时间。<br>&emsp;&emsp;（11）    FAT32文件系统初始化：获取SD卡文件使用情况，准备对日志文件的写入。<br>&emsp;&emsp;（12）    系统定时的初始化：通过装载的时间开启，REAL-TIME计时。<br>&emsp;&emsp;（13）    滤波FIFO，数据FIFO结构体的初始化。</p>
<h3 id="4-3-数据的处理"><a href="#4-3-数据的处理" class="headerlink" title="4.3 数据的处理"></a>4.3 数据的处理</h3><h4 id="4-3-1-温度湿度数据采集"><a href="#4-3-1-温度湿度数据采集" class="headerlink" title="4.3.1 温度湿度数据采集"></a>4.3.1 温度湿度数据采集</h4><p>&emsp;&emsp;HTU21D的温度湿度采集主要有四个指令：<br>&emsp;&emsp;&emsp;&emsp;（1）温度保持主机模式<br>&emsp;&emsp;&emsp;&emsp;（2）湿度保持主机模式<br>&emsp;&emsp;&emsp;&emsp;（3）温度非保持主机模式<br>&emsp;&emsp;&emsp;&emsp;（4）湿度非保持主机模式</p>
<p>&emsp;&emsp;温度使用14位AD分辨率，湿度采用12位AD分辨率，采样指令发出启动采样后，我们默认使用保持主机模式（快速）。之后HTU21D会以大端的方式发送3字节数据，最后一字节是校验和。</p>
<p>&emsp;&emsp;程序的重点是轮询HTU21D的ACK信号（保持主机模式），之后接收3字节的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">SHT2x_MeasureTempHM</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> TEMP;</span><br><span class="line">    u8 tmp1, tmp2;</span><br><span class="line">    u16 ST;</span><br><span class="line">    </span><br><span class="line">    SHT2x_SCL_OUTPUT();</span><br><span class="line">    SHT2x_I2cStartCondition();                            </span><br><span class="line">    SHT2x_I2cWriteByte(I2C_ADR_W);</span><br><span class="line">    SHT2x_I2cWriteByte(TRIG_TEMP_MEASUREMENT_HM);</span><br><span class="line">    SHT2x_I2cStartCondition();</span><br><span class="line">    SHT2x_I2cWriteByte(I2C_ADR_R);</span><br><span class="line">    SHT2x_SCL_HIGH();</span><br><span class="line">    SHT2x_SCL_INPUT();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(Bit_RESET == SHT2x_SCL_STATE())</span><br><span class="line">    &#123;</span><br><span class="line">        SHT2x_Delay(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    tmp1 = SHT2x_I2cReadByte();</span><br><span class="line">    SHT2x_I2cAcknowledge();</span><br><span class="line">    tmp2 = SHT2x_I2cReadByte();</span><br><span class="line">    SHT2x_I2cNoAcknowledge();</span><br><span class="line">    SHT2x_I2cStopCondition();</span><br><span class="line">    ST = (tmp1 &lt;&lt; <span class="number">8</span>) | (tmp2 &lt;&lt; <span class="number">0</span>);</span><br><span class="line">    ST &amp;= ~<span class="number">0x0003</span>;</span><br><span class="line">    TEMP = ((<span class="keyword">float</span>)ST * <span class="number">0.00268127</span>) - <span class="number">46.85</span>;</span><br><span class="line">    SHT2x_SCL_OUTPUT();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (TEMP);	  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">SHT2x_MeasureHumiHM</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> HUMI;</span><br><span class="line">    u8 tmp1, tmp2;    </span><br><span class="line">    u16 SRH;</span><br><span class="line"></span><br><span class="line">    SHT2x_SCL_OUTPUT();</span><br><span class="line">    SHT2x_I2cStartCondition();                               </span><br><span class="line">    SHT2x_I2cWriteByte(I2C_ADR_W);</span><br><span class="line">    SHT2x_I2cWriteByte(TRIG_HUMI_MEASUREMENT_HM);</span><br><span class="line">    SHT2x_I2cStartCondition();</span><br><span class="line">    SHT2x_I2cWriteByte(I2C_ADR_R);</span><br><span class="line">    SHT2x_SCL_HIGH();</span><br><span class="line">    SHT2x_SCL_INPUT();</span><br><span class="line">    <span class="keyword">while</span>(Bit_RESET == SHT2x_SCL_STATE())</span><br><span class="line">    &#123;</span><br><span class="line">        SHT2x_Delay(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    tmp1 = SHT2x_I2cReadByte();</span><br><span class="line">    SHT2x_I2cAcknowledge();</span><br><span class="line">    tmp2 = SHT2x_I2cReadByte();</span><br><span class="line">    SHT2x_I2cNoAcknowledge();</span><br><span class="line">    SHT2x_I2cStopCondition();</span><br><span class="line">    SRH = (tmp1 &lt;&lt; <span class="number">8</span>) | (tmp2 &lt;&lt; <span class="number">0</span>);</span><br><span class="line">    SRH &amp;= ~<span class="number">0x0003</span>;</span><br><span class="line">    HUMI = ((<span class="keyword">float</span>)SRH * <span class="number">0.00190735</span>) - <span class="number">6</span>;</span><br><span class="line">    SHT2x_SCL_OUTPUT();</span><br><span class="line">    <span class="keyword">return</span> (HUMI);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;温湿度的数据在通过校验和校验后会送入滤波FIFO队列。</p>
<h4 id="4-3-2-灰尘数据采集"><a href="#4-3-2-灰尘数据采集" class="headerlink" title="4.3.2 灰尘数据采集"></a>4.3.2 灰尘数据采集</h4><p>&emsp;&emsp;这个部分的程序写的是很有技巧的，因为这个传感器一开机就会不断的发数据，并没有传输完成中断，所以如果用轮训的方式接收数据，会严重浪费CPU的资源，我们设计了串口中断即时接收即时分析，大大提高了数据处理的效率。下面展示一下程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART1_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)</span><br><span class="line">		&#123;</span><br><span class="line">			USART_ClearITPendingBit(USART1, USART_IT_RXNE);		</span><br><span class="line">			RX_FIFO[rxCount] = USART_ReceiveData(USART1);</span><br><span class="line">			rxCount ++;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clrRxCount</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">uint16_t</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;rxCount;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			RX_FIFO[i] =  <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		rxCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">gp2yReadAData</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">uint8_t</span> i;</span><br><span class="line">		<span class="keyword">float</span> dustnum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		REGET:USART_ITConfig(PM_USARTx, USART_IT_RXNE, ENABLE);</span><br><span class="line">		<span class="keyword">while</span>( rxCount != <span class="number">7</span>* FIFO_GROUP_NUM);</span><br><span class="line">		USART_ITConfig(PM_USARTx, USART_IT_RXNE, DISABLE);</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">7</span>* FIFO_GROUP_NUM; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(RX_FIFO[i] == <span class="number">0xaa</span>)</span><br><span class="line">			&#123;</span><br><span class="line"><span class="keyword">if</span>(RX_FIFO[i+<span class="number">1</span>] + RX_FIFO[i+<span class="number">2</span>] + RX_FIFO[i+<span class="number">3</span>] + RX_FIFO[i+<span class="number">4</span>] == RX_FIFO[i+<span class="number">5</span>])</span><br><span class="line">				&#123;</span><br><span class="line">dustnum = ( (<span class="keyword">float</span>)RX_FIFO[i+<span class="number">1</span>] *<span class="number">256</span> + (<span class="keyword">float</span>)RX_FIFO[i+<span class="number">2</span>] ) *<span class="number">5</span> *K_VALUE /<span class="number">1024</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		clrRxCount();</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">7</span>* FIFO_GROUP_NUM)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">goto</span> REGET;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> dustnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;PM2.5的数据获取之后会送入滤波FIFO队列。</p>
<h4 id="4-3-3-卡尔曼滤波"><a href="#4-3-3-卡尔曼滤波" class="headerlink" title="4.3.3 卡尔曼滤波"></a>4.3.3 卡尔曼滤波</h4><p>&emsp;&emsp;传统的滤波方法，只能是在有用信号与噪声具有不同频带的条件下才能实现．20世纪40年代，N．维纳和A．H．柯尔莫哥罗夫把信号和噪声的统计性质引进了滤波理论，在假设信号和噪声都是平稳过程的条件下，利用最优化方法对信号真值进行估计，达到滤波目的，从而在概念上与传统的滤波方法联系起来，被称为维纳滤波。这种方法要求信号和噪声都必须是以平稳过程为条件。60年代初，卡尔曼(R．E．Kalman)和布塞(R． S．Bucy)发表了一篇重要的论文《线性滤波和预测 理论的新成果》，提出了一种新的线性滤波和预测理由论，被称之为卡尔曼滤波。特点是在线性状态空间表示的基础上对有噪声的输入和观测信号进行处理，求取系统状态或真实信号。</p>
<p>&emsp;&emsp;这种理论是在时间域上来表述的，基本的概念是：在线性系统的状态空间表示基础上，从输出和输入观测数据求系统状态的最优估计。这里所说的系统状态，是总结系统所有过去的输入和扰动对系统的作用的最小参数的集合，知道了系统的状态就能够与未来的输入与系统的扰动一起确定系统的整个行为。</p>
<p>&emsp;&emsp;卡尔曼滤波不要求信号和噪声都是平稳过程的假设条件。对于每个时刻的系统扰动和观测误差（即噪声），只要对它们的统计性质作某些适当的假定，通过对含有噪声的观测信号进行处理，就能在平均的意义上，求得误差为最小的真实信号的估计值。因此，自从卡尔曼滤波理论问世以来，在通信系统、电力系统、航空航天、环境污染控制、工业控制、雷达信号处理等许多部门都得到了应用，取得了许多成功应用的成果。例如在图像处理方面，应用卡尔曼滤波对由于某些噪声影响而造成模糊的图像进行复原。在对噪声作了某些统计性质的假定后，就可以用卡尔曼的算法以递推的方式从模糊图像中得到均方差最小的真实图像，使模糊的图像得到复原。</p>
<p>&emsp;&emsp;对于温度湿度和灰尘的模型我们选用了无控制离散型卡尔曼滤波器公式：</p>
<div align="center"><img src="/数据采集记录系统/figure.21.JPG" alt="图21"><br></div>

<div align="center"><img src="/数据采集记录系统/figure.22.JPG" alt="图22"><br></div>

<p>&emsp;&emsp;无控制的一阶卡尔曼滤波是十分简单的，我们很快就用C实现了这个算法，展示一下对一段温度数据的滤波：</p>
<div align="center"><img src="/数据采集记录系统/figure.23.JPG" alt="图23"><br></div>

<p>&emsp;&emsp;初给值为25℃，P值初给值为10，在调完Q值和R值后，可以得到更好的性能。</p>
<h4 id="4-3-4-哈夫曼编码压缩数据"><a href="#4-3-4-哈夫曼编码压缩数据" class="headerlink" title="4.3.4 哈夫曼编码压缩数据"></a>4.3.4 哈夫曼编码压缩数据</h4><p>&emsp;&emsp;哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式，哈夫曼编码是可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，该方法完全依据字符出现概率来构造异字头的平均长度最短的码字，有时称之为最佳编码，一般就叫做Huffman编码（有时也称为霍夫曼编码）。</p>
<p>&emsp;&emsp;设某信源产生有五种符号u1、u2、u3、u4和u5，对应概率P1=0．4，P2=0．1，P3=P4=0．2，P5=0．1。首先，将符号按照概率由大到小排队，如图所示。编码时，从最小概率的两个符号开始，可选其中一个支 路为0，另一支路为1。这里，我们选上支路为0，下支路为1。再将已编码的两支路的概率合并，并重新排队。多次重复使用上述方法直至合并概率归一时为止。从图（a）和（b）可以看出，两者虽平均码长相等，但同一符号可以有不同的码长，即编码方法并不唯一，其原因是两支路概率合并后重新排队时，可能出现几个支路概率相等，造成排队方法不唯一。一般，若将新合并后的支路排到等概率的最上支路，将有利于缩短码长方差，且编出的码更接近于等长码。这里图（a）的编码比（b）好。</p>
<p>&emsp;&emsp;赫夫曼码的码字（各符号的代码是异前置码字，即任一码字不会是另一码字的前面部分，这使各码字可以连在一起传送，中间不需另加隔离符号，只要传送时不出错，收端仍可分离各个码字，不致混淆。</p>
<p>&emsp;&emsp;实际应用中，除采用定时清洗以消除误差扩散和采用缓冲存储以解决速率匹配以外，主要问题是解决小符号集合的统计匹配，例如黑（1）、白（0）传真信源的统计匹配，采用0和1不同长度游程组成扩大的符号集合信源。游程，指相同码元的长度（如二进码中连续的一串0或一串1的长度或个数）。按照CCITT标准，需要统计2×1728种游程（长度），这样，实现时的存储量太大。事实上长游程的概率很小，故CCITT还规定：若l表示游程长度，则l=64q+r。其中q称主码，r为基码。编码时，不小于64的游程长度由主码和基码组成。而当l为64的整数倍时，只用主码的代码，已不存在基码的代码。</p>
<p>&emsp;&emsp;长游程的主码和基码均用赫夫曼规则进行编码，这称为修正赫夫曼码，其结果有表可查。该方法已广泛应用于文件传真机中。</p>
<p>&emsp;&emsp;在我们的设备中，哈夫曼编码的压缩没有应用到短信之中，因为它的字典是不固定的，所以每次数据的传输，还得附上字典，用在短信上，压缩率反而会因为字典降低。所以我们的短信传输是使用一种固定字典编码叫强哥编码，在GPRS或者串口等数据足够大的数据流采用哈夫曼编码压缩。</p>
<p>&emsp;&emsp;以下是算法实现，重点是根据哈夫曼树对数据字符编码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct BTreeNode* <span class="title">CreateHuffman</span><span class="params">(ElemType a[], <span class="keyword">uint8_t</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">uint16_t</span> i, j;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span> **<span class="title">b</span>, *<span class="title">q</span>;</span>  </span><br><span class="line">    b = <span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(struct BTreeNode));  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        b[i] = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct BTreeNode));  </span><br><span class="line">        b[i]-&gt;data = a[i];  </span><br><span class="line">        b[i]-&gt;left = b[i]-&gt;right = <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">int</span> k1 = <span class="number">-1</span>, k2;  </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span> (b[j] != <span class="literal">NULL</span> &amp;&amp; k1 == <span class="number">-1</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                k1 = j;  </span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (b[j] != <span class="literal">NULL</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                k2 = j;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span> (j = k2; j &lt; n; j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span> (b[j] != <span class="literal">NULL</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">if</span> (b[j]-&gt;data &lt; b[k1]-&gt;data)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    k2 = k1;  </span><br><span class="line">                    k1 = j;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (b[j]-&gt;data &lt; b[k2]-&gt;data)  </span><br><span class="line">                    k2 = j;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">         </span><br><span class="line">        q = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct BTreeNode));  </span><br><span class="line">        q-&gt;data = b[k1]-&gt;data + b[k2]-&gt;data;  </span><br><span class="line">        q-&gt;left = b[k1];  </span><br><span class="line">        q-&gt;right = b[k2];  </span><br><span class="line">  </span><br><span class="line">        b[k1] = q;  </span><br><span class="line">        b[k2] = <span class="literal">NULL</span>; </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">free</span>(b);   </span><br><span class="line">    <span class="keyword">return</span> q; </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffManCoding</span><span class="params">(struct BTreeNode* FBT, <span class="keyword">int</span> len, struct EnCodeBuff encodegroup[] ,<span class="keyword">uint8_t</span> numofgroup)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uint8_t</span> a[CODE_MAX_SIZE];  </span><br><span class="line">    <span class="keyword">if</span> (FBT != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (FBT-&gt;left == <span class="literal">NULL</span> &amp;&amp; FBT-&gt;right == <span class="literal">NULL</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">uint16_t</span> ii;  </span><br><span class="line">            <span class="keyword">uint8_t</span> i;  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(ii = <span class="number">0</span>; ii &lt; numofgroup; ii++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(FBT-&gt;data==encodegroup[ii].weight&amp;&amp;encodegroup[ii].havecoded == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    encodegroup[ii].havecoded = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)  </span><br><span class="line">            &#123;</span><br><span class="line">                encodegroup[ii].code[i] = a[i];</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG_PC</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>, a[i]);  </span><br><span class="line">                <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">            encodegroup[ii].code[i] = <span class="number">2</span>; </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;   </span><br><span class="line">            a[len] = <span class="number">0</span>;  </span><br><span class="line">            HuffManCoding(FBT-&gt;left, len + <span class="number">1</span>, encodegroup, numofgroup);  </span><br><span class="line">            a[len] = <span class="number">1</span>;  </span><br><span class="line">            HuffManCoding(FBT-&gt;right, len + <span class="number">1</span>, encodegroup, numofgroup);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function">struct EnCodeBuff* <span class="title">huffmanStrEncoding</span><span class="params">(<span class="keyword">uint8_t</span> *tarstr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">EnCodeBuff</span> <span class="title">EnCodegroup</span>[<span class="title">STRSORTBUFFER_SIZE</span>];</span></span><br><span class="line">    <span class="keyword">uint16_t</span> i,ii;</span><br><span class="line">    <span class="keyword">uint8_t</span> numofch=<span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span>* <span class="title">fbt</span>;</span> </span><br><span class="line"></span><br><span class="line">    ElemType* weightbuff; </span><br><span class="line">    <span class="keyword">while</span>(*tarstr!= <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(ii= <span class="number">0</span>;ii&lt; <span class="built_in">strlen</span>(tarstr);ii++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numofch != <span class="number">0</span>)</span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="keyword">for</span>(i= <span class="number">0</span>; i&lt; numofch;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(*tarstr == EnCodegroup[i].ch)</span><br><span class="line">                    &#123;</span><br><span class="line">                        EnCodegroup[i].weight ++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i == numofch)</span><br><span class="line">                &#123;</span><br><span class="line">                    EnCodegroup[i].ch = *tarstr;  </span><br><span class="line">                    EnCodegroup[i].weight = <span class="number">1</span>;  </span><br><span class="line">                    EnCodegroup[i].havecoded = <span class="number">0</span>;  </span><br><span class="line">                    numofch++;</span><br><span class="line">                &#125;</span><br><span class="line">                tarstr++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                numofch++;</span><br><span class="line">                EnCodegroup[<span class="number">0</span>].ch = *tarstr;</span><br><span class="line">                EnCodegroup[<span class="number">0</span>].weight = <span class="number">1</span>;</span><br><span class="line">                EnCodegroup[<span class="number">0</span>].havecoded = <span class="number">0</span>;  </span><br><span class="line">                tarstr++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    EnCodegroup[numofch].ch = <span class="string">'\0'</span>;</span><br><span class="line">    weightbuff = <span class="built_in">malloc</span>( numofch*<span class="keyword">sizeof</span>( ElemType));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;numofch; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        weightbuff[i] = EnCodegroup[i].weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fbt = CreateHuffman(weightbuff ,numofch);</span><br><span class="line">    HuffManCoding(fbt, <span class="number">0</span>, EnCodegroup, numofch); </span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(weightbuff);</span><br><span class="line">    <span class="keyword">return</span> EnCodegroup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;程序的核心就是用递归建哈夫曼树，然后又树根对字符按频率编码，最后经过我们的测试，哈夫曼的压缩率有20-40%，不算上字典，这是多么强大的压缩算法。</p>
<div align="center"><img src="/数据采集记录系统/figure.24.JPG" alt="图24"><br></div>

<div align="center"><img src="/数据采集记录系统/figure.25.JPG" alt="图25"><br></div>

<h4 id="4-3-5-强哥编码压缩数据"><a href="#4-3-5-强哥编码压缩数据" class="headerlink" title="4.3.5 强哥编码压缩数据"></a>4.3.5 强哥编码压缩数据</h4><p>&emsp;&emsp;强哥编码是一种固定字典编码，为什么叫强哥编码呢，因为他的字典是由我的队友黎殿强设计的，两边端都持有一份字典，压缩率固定为50%（固定使用常用16个字符）。效果也是非常优秀的，下面展示一下编码和解码算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint16_t</span> mssJonhgoEncode(<span class="keyword">uint8_t</span> *tarstr, <span class="keyword">uint8_t</span> *outstr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint16_t</span> bytenum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uint8_t</span> i=<span class="number">0</span>, bitnumofcodemap = <span class="number">0</span>, bitnumofcodedmss = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(*tarstr != <span class="string">'\0'</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(*tarstr == Jonhgocode[i].ch)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(bitnumofcodemap &lt; <span class="number">4</span>) </span><br><span class="line">			&#123;	</span><br><span class="line">				<span class="keyword">if</span> (bitnumofcodedmss &gt; <span class="number">7</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					bitnumofcodedmss = <span class="number">0</span>;</span><br><span class="line">					bytenum ++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;					</span><br><span class="line">					<span class="keyword">if</span>(Jonhgocode[i].code[bitnumofcodemap] == <span class="number">1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						SetN1(&amp;outstr[bytenum], bitnumofcodedmss); 	 </span><br><span class="line">						bitnumofcodemap ++;</span><br><span class="line">						bitnumofcodedmss ++;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (Jonhgocode[i].code[bitnumofcodemap] == <span class="number">0</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						SetN0(&amp;outstr[bytenum], bitnumofcodedmss); </span><br><span class="line">						bitnumofcodemap ++;			</span><br><span class="line">						bitnumofcodedmss ++;		</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			tarstr++;</span><br><span class="line">			i = <span class="number">0</span>;</span><br><span class="line">			bitnumofcodemap = <span class="number">0</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>+bytenum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> mssDecodeJonhgo(<span class="keyword">uint8_t</span> *tarstr, <span class="keyword">uint8_t</span> *outstr)</span><br><span class="line">&#123;	</span><br><span class="line">	<span class="keyword">uint16_t</span>  bytenum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uint8_t</span> i=<span class="number">0</span>, bitnumofcodemap = <span class="number">0</span>, bitnumofcodedmss = <span class="number">0</span>, endflag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(endflag &lt; <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(bitnumofcodemap &lt; <span class="number">4</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(bitnumofcodedmss &gt; <span class="number">7</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				tarstr++;</span><br><span class="line">				bitnumofcodedmss = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line"><span class="keyword">if</span>(Get1Bit(*tarstr,bitnumofcodedmss)==Jonhgocode[i].code[bitnumofcodemap])</span><br><span class="line">				&#123;</span><br><span class="line">					bitnumofcodemap ++;</span><br><span class="line">					bitnumofcodedmss ++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					i++;</span><br><span class="line">					bitnumofcodemap = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">if</span>(bitnumofcodedmss &gt;= <span class="number">4</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						bitnumofcodedmss = <span class="number">4</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						bitnumofcodedmss = <span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		outstr[bytenum] = Jonhgocode[i].ch;</span><br><span class="line">		bitnumofcodemap = <span class="number">0</span>;</span><br><span class="line">		i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(outstr[bytenum] == <span class="string">'#'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			endflag ++ ;</span><br><span class="line">		&#125;</span><br><span class="line">		bytenum ++ ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-6-发送短信"><a href="#4-3-6-发送短信" class="headerlink" title="4.3.6 发送短信"></a>4.3.6 发送短信</h4><p>&emsp;&emsp;由于我们需要传送压缩后的数据，所以短信的格式要选用PDU格式的短信，如果用TEXT格式的短信，发送一个字符是7位的，我们的数据是8位的，发过去会丢失数据。而PDU格式可以发送16位和8位的数据。</p>
<p>&emsp;&emsp;PDU的短信编码是比较复杂的，发送方PDU格式：</p>
<p>&emsp;SCA        PDU-Type    MR    DA        PID    DCS    VP        UDL    UD<br>&emsp;1-12    1            1    2-12    1    1    0,1,7    1    0-140</p>
<p>&emsp;&emsp;底层的发送PDU驱动是这样写的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> gsmSendPDUMessDefault(<span class="keyword">uint8_t</span> *tphone,<span class="keyword">uint8_t</span> *infTemp, <span class="keyword">uint16_t</span> inflen)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint8_t</span> i,phonelen,fullasonebyte = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uint8_t</span> phonenumcodetemp[MSS_COMMON_BUFFER_SIZE]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(inflen &gt;<span class="number">140</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(inflen %<span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		fullasonebyte = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	phonelen = <span class="built_in">strlen</span>(tphone);</span><br><span class="line">	</span><br><span class="line">	USART3_printf(<span class="string">"AT+CMGS=%d\r"</span>, (inflen + <span class="number">15</span> + fullasonebyte) );</span><br><span class="line">	<span class="keyword">while</span>( <span class="built_in">strstr</span>(RX_BUFFER , <span class="string">"&gt;"</span>) == <span class="literal">NULL</span>);</span><br><span class="line">	clrRxCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(phonelen %<span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    		phone[phonelen] = <span class="string">'F'</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">12</span>;i = i+<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">    				honenumcodetemp[i] = tphone[i+<span class="number">1</span>];</span><br><span class="line">    				honenumcodetemp[i+<span class="number">1</span>] = tphone[i];</span><br><span class="line">   			&#125;</span><br><span class="line">tphone[phonelen] = <span class="string">'\0'</span>;</span><br><span class="line">    		&#125;</span><br><span class="line"></span><br><span class="line">USART3_printf(<span class="string">"0891683108705505F011000D91%s0008A7%02x"</span>, phonenumcodetemp, (inflen + fullasonebyte) );</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;inflen; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			USART3_printf(<span class="string">"%02x"</span>, infTemp[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (fullasonebyte == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			USART3_printf(<span class="string">"00"</span>); </span><br><span class="line">		&#125;</span><br><span class="line">		USART_SendData(USART3 ,<span class="number">0x1a</span>);</span><br><span class="line">		<span class="keyword">while</span>( <span class="built_in">strstr</span>(RX_BUFFER , <span class="string">"OK"</span>) == <span class="literal">NULL</span>);</span><br><span class="line">		clrRxCount();</span><br><span class="line">	</span><br><span class="line">		ODDCsystem.senttimes ++;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-7-SD卡日志写入"><a href="#4-3-7-SD卡日志写入" class="headerlink" title="4.3.7 SD卡日志写入"></a>4.3.7 SD卡日志写入</h4><p>&emsp;&emsp;SD卡数据记录是个重磅的功能，因为依靠GSM发送数据储存是不稳定的，必须有一个100%能写入到数据的方法。我们设计了基于FAT32文件系统的SD卡数据记录程序，数据会以电脑，手机等终端都可读的TXT文件储存。设备会定期写入采集的数据，系统运行的状态，也就是系统的运行日志，如果设备坏了，可以取SD卡分析，相当于黑盒子。由于关于SD卡的算法有几千行的C代码，所以就不展示了。介绍一下FAT32：</p>
<p>&emsp;&emsp;FAT32是Windows系统硬盘分区格式的一种。这种格式采用32位的文件分配表，使其对磁盘的管理能力大大增强，突破了FAT16对每一个分区的容量只有2 GB的限制。由于现在的硬盘生产成本下降，其容量越来越大，运用FAT32的分区格式后，我们可以将一个大硬盘定义成一个分区而不必分为几个分区使用，大大方便了对磁盘的管理。</p>
<p>&emsp;&emsp;FAT32格式的结构如下：</p>
<p>&emsp;&emsp;保留扇区<br>&emsp;&emsp;位于最开始的位置。第一个保留扇区是引导区（分区启动记录）。它包括一个称为基本输入输出参数块的区域（包括一些基本的文件系统信息尤其是它的类型和其它指向其它扇区的指针），通常包括操作系统的启动调用代码。保留扇区的总数记录在引导扇区中的一个参数中。引导扇区中的重要信息可以被DOS和OS/2中称为驱动器参数块的操作系统结构访问。</p>
<p>&emsp;&emsp;FAT区域<br>&emsp;&emsp;它包含有两份文件分配表，这是出于系统冗余考虑，尽管它很少使用，即使是磁盘修复工具也很少使用它。它是分区信息的映射表，指示簇是如何存储的。</p>
<p>&emsp;&emsp;根目录区域<br>&emsp;&emsp;它是在根目录中存储文件和目录信息的目录表。在FAT32下它可以存在分区中的任何位置，但是在早期的版本中它永远紧随FAT区域之后。</p>
<p>&emsp;&emsp;数据区域<br>&emsp;&emsp;这是实际的文件和目录数据存储的区域，它占据了分区的绝大部分。通过简单地在FAT中添加文件链接的个数可以任意增加文件大小和子目录个数（只要有空簇存在）。然而需要注意的是每个簇只能被一个文件占有，这样的话如果在32KB大小的簇中有一个1KB大小的文件，那么31KB的空间就浪费掉了。</p>
<p>&emsp;&emsp;我们的设备在SD卡上读写的文档是ODDCLOG.TXT:</p>
<div align="center"><img src="/数据采集记录系统/figure.26.JPG" alt="图26"><br></div>

<h3 id="4-4-LCD显示交互系统设计"><a href="#4-4-LCD显示交互系统设计" class="headerlink" title="4.4 LCD显示交互系统设计"></a>4.4 LCD显示交互系统设计</h3><p>&emsp;&emsp;数据的即时反馈是显示在一块液晶屏幕上的，屏幕尺寸很大，128X64，我们很好在上面开发。于是我们设计了个交互系统，用户通过四个按键来操控MENU。当系统状态机在IDLE状态时，屏幕的一级菜单是显示当前北京时间，温度，湿度和PM2.5。当用户按击菜单按钮，系统会进入二级菜单，在二级菜单中，用户可以继续通过向上选择和向下选择按钮，选择相应的三级菜单：①发送一组当前三个传感值加上时间，②设置向终端发送短信的频率以及手动启动联网对时，③选择发送终端，④查看系统状态。</p>
<div align="center"><img src="/数据采集记录系统/figure.27.JPG" alt="图27"><br></div>

<p>&emsp;&emsp;从我们的功能流程图可以清楚的看出，用户可以很方便的对整个设备进行设置，浏览数据，以及维护。通过按键以及LED灯与用户进行交互，同时系统的异常处理也会在LCD上显示出来。</p>
<h3 id="4-5-系统异常处理"><a href="#4-5-系统异常处理" class="headerlink" title="4.5 系统异常处理"></a>4.5 系统异常处理</h3><p>&emsp;&emsp;野外环境是不稳定的，我们采取了独立看门狗，用来防止设备程序跑飞，另外SIM卡异常和SD卡异常是通过初始化时检测，将异常记录到日志，并且用LCD发出警报。</p>
<p>&emsp;&emsp;STM32 的独立看门狗由内部专门的 40Khz 低速时钟驱动，即使主时钟发生故障，它也仍然有效。</p>
<p>&emsp;&emsp;看门狗的原理：单片机系统在外界的干扰下会出现程序跑飞的现象导致出现死循环，看门狗电路就是为了避免这种情况的发生。看门狗的作用就是在一定时间内（通过定时计数器实现）没有接收喂狗信号（表示 MCU 已经挂了），便实现处理器的自动复位重启（发送复位信号） 。</p>
<p>&emsp;&emsp;在键值寄存器(IWDG_KR)中写入 0xCCCC，开始启用独立看门狗；此时计数器开始从其复位值 0xFFF 递减计数。当计数器计数到末尾 0x000 时，会产生一个复位信号(IWDG_RESET)。无论何时，只要键寄存器 IWDG_KR 中被写入 0xAAAA，  IWDG_RLR 中的值就会被重新加载到计数器中从而避免产生看门狗复位  。</p>
<p>&emsp;&emsp;IWDG_PR 和 IWDG_RLR 寄存器具有写保护功能。要修改这两个寄存器的值，必须先向IWDG_KR 寄存器中写入 0x5555。将其他值写入这个寄存器将会打乱操作顺序，寄存器将重新被保护。重装载操作(即写入 0xAAAA)也会启动写保护功能。</p>
<p>&emsp;&emsp;只要对以上三个寄存器进行相应的设置，我们就可以启动 STM32 的独立看门狗，启动过程可以按如下步骤实现：</p>
<p>&emsp;&emsp;1）取消寄存器写保护（向 IWDG_KR 写入 0X5555）<br>&emsp;&emsp;通过这步，我们取消 IWDG_PR 和 IWDG_RLR 的写保护，使后面可以操作这两个寄存器,设置 IWDG_PR 和 IWDG_RLR 的值。这在库函数中的实现函数是：<br>&emsp;&emsp;void IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);</p>
<p>&emsp;&emsp;2）设置独立看门狗的预分频系数和重装载值<br>&emsp;&emsp;设置看门狗的分频系数的函数是：<br>&emsp;&emsp;void IWDG_SetPrescaler(uint8_t IWDG_Prescaler);  </p>
<p>&emsp;&emsp;设置看门狗的重装载值的函数是：<br>&emsp;&emsp;void IWDG_SetReload(uint16_t Reload);<br>&emsp;&emsp;设置好看门狗的分频系数 prer 和重装载值就可以知道看门狗的喂狗时间（也就是看门狗溢出时间），该时间的计算方式为：<br>&emsp;&emsp;Tout=((4×2^prer)×rlr) /40<br>&emsp;&emsp;其中 Tout 为看门狗溢出时间（单位为ms） ；prer 为看门狗时钟预分频值（IWDG_PR 值），范围为 0~7；rlr 为看门狗的重装载值（IWDG_RLR的值） ；<br>&emsp;&emsp;比如我们设定 prer 值为 4， rlr 值为 625，那么就可以得到 Tout=64×625/40=1000ms，这样，看门狗的溢出时间就是 1s，只要你在一秒钟之内，有一次写入 0XAAAA 到 IWDG_KR，就不会导致看门狗复位（当然写入多次也是可以的）。这里需要提醒大家的是，看门狗的时钟不是准确的 40Khz，所以在喂狗的时候，最好不要太晚了，否则，有可能发生看门狗复位。</p>
<p>&emsp;&emsp;3）重载计数值喂狗（向 IWDG_KR 写入 0XAAAA）<br>&emsp;&emsp;库函数里面重载计数值的函数是：<br>&emsp;&emsp;IWDG_ReloadCounter();<br>&emsp;&emsp;通过这句，将使 STM32 重新加载 IWDG_RLR 的值到看门狗计数器里面。 即实现独立看门狗的喂狗操作。</p>
<p>&emsp;&emsp;4)启动看门狗(向 IWDG_KR 写入 0XCCCC)<br>&emsp;&emsp;库函数里面启动独立看门狗的函数是：<br>&emsp;&emsp;IWDG_Enable();<br>&emsp;&emsp;当设备跑飞了，喂狗失败，会启动系统复位，设备重新启动进入初始化。    </p>
<div align="center"><img src="/数据采集记录系统/figure.28.JPG" alt="图28"><br></div>

<h2 id="第五章-手机上位APP软件设计"><a href="#第五章-手机上位APP软件设计" class="headerlink" title="第五章 手机上位APP软件设计"></a>第五章 手机上位APP软件设计</h2><h3 id="5-1-APP系统框图"><a href="#5-1-APP系统框图" class="headerlink" title="5.1 APP系统框图"></a>5.1 APP系统框图</h3><div align="center"><img src="/数据采集记录系统/figure.29.JPG" alt="图29"><br></div>

<h3 id="5-2-APP原理"><a href="#5-2-APP原理" class="headerlink" title="5.2 APP原理"></a>5.2 APP原理</h3><p>&emsp;&emsp;在打开app后，首先会进入一个加载动画特效，app会在进入主界面之前读取所有的数据短信，读取完成后会以一个特效进入主界面。主界面有三个具有折叠效果的下拉式菜单，每个菜单设定了3个按钮，当按下查看数据或者操作数据菜单中的按钮时，会进入一个选择地点、年月日的界面，并把按钮的信息传到该界面。选择完成后，该界面会根据主界面中按下的按钮类型觉得进入哪一个界面。如果按下的是查看数据菜单中的按钮，会进入一个画图的界面，把相应的图表绘画出来；如果按下的是写入或者修改数据按钮，会进入一个输入温度、湿度、pm2.5的数据的界面，输入完成后，便可把数据保存到数据库中；如果按下的是删除数据按钮，则会进入一个选择所要删除的数据的界面，确认后，便可将该数据删除。号码绑定是进入一个界面输入地点与数据来源的sim卡号码一一对应，从而实现多地点检测。导入库可以将现成的一个月乃至一年的数据导入到该app中，从而简化了人工操作。更新短信的功能是为了接收app运行期间的数据信息。</p>
<p>&emsp;&emsp;下面将分别介绍如何实现短信的识别接收、短信数据的解码、使用litepal建立数据库、短信数据写入数据库与防重复读写、sim卡号码与地点的绑定、从数据库中获得数据、根据数据绘制表格。</p>
<h3 id="5-2-1-短信的接收识别"><a href="#5-2-1-短信的接收识别" class="headerlink" title="5.2.1 短信的接收识别"></a>5.2.1 短信的接收识别</h3><p>&emsp;&emsp;1）短信的读取<br>&emsp;&emsp;&emsp;在android app中，要获得手机中的短信数据，必须首先得到阅读短信的权限。这个权限只需在  androidMainifest.xml文件中添加以下一行代码便可：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_SMS"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;&emsp;然后，设定一个手机短信UrI，通过函数:<br>Cursorandroid.content.ContentResolver.query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)即可追踪查询手机短信内容。Uri的取值确定所查询的手机短信类型。</p>
<p>&emsp;&emsp;&emsp;下面列出该uri取值跟所读取手机短信的对应关系：<br>&emsp;&emsp;&emsp;所有短信：content://sms/all<br>&emsp;&emsp;&emsp;收信箱：content://sms/inbox<br>&emsp;&emsp;&emsp;已发送：content://sms/sent<br>&emsp;&emsp;&emsp;草稿：content://sms/draft<br>&emsp;&emsp;&emsp;发件箱：content://sms/outbox<br>&emsp;&emsp;&emsp;发送失败：content://sms/failed<br>&emsp;&emsp;&emsp;排队消息:content://sms/queued<br>&emsp;&emsp;&emsp;未送达的短信：content://sms/undelivered<br>&emsp;&emsp;&emsp;对话：content://sms/conversations<br>&emsp;&emsp;&emsp;显然，在该app中，只需读取收信箱中的短信即可。<br>&emsp;&emsp;&emsp;于是， 取  Uri uri = “content://sms/inbox”；<br>&emsp;&emsp;&emsp;然后调用函数int Cursor.getColumnIndex(Stringarg0)<br>&emsp;&emsp;&emsp;就可以得到每条短信的各种内容。arg0的设定跟所读取的内容有如下关系：<br>&emsp;&emsp;&emsp;短信id:              _id<br>&emsp;&emsp;&emsp;号码：               address<br>&emsp;&emsp;&emsp;联系人：              person<br>&emsp;&emsp;&emsp;短信内容：            body<br>&emsp;&emsp;&emsp;日期：                date<br>&emsp;&emsp;&emsp;类型：                type<br>&emsp;&emsp;&emsp;在该app中需要读取的内容为短信内容和号码，于是，设定了两个索引：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> smsbodyColumn=cur.getColumnIndex(“body”);</span><br><span class="line"><span class="keyword">int</span> smsaddressColumn=cur.getColumnIndex(“address”);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;&emsp;再通过函数cur.getString(int arg0)函数就可以直接获得短信内容与相应号码；</p>
<p>&emsp;&emsp;2）识别数据短信<br>&emsp;&emsp;&emsp;到这里，已经成功地读取了所需的手机短信内容。但是手机上短信肯定不是全部是数据短信，怎样才能哪些是app所需的短信呢？</p>
<p>&emsp;&emsp;&emsp;在这里，我们共同确定了一个识别码为  #D，当app读到的手机短信内容的前两个编码方式为ucf-8的字符为 “#D”时，由于这个序列是我们日常中几乎不可能使用的，于是可以确定这个就是app需要读取的数据短信。</p>
<p>&emsp;&emsp;&emsp;然而，这里需要解决一个问题，gsm模块发送过来的是经过压缩的数据，而且手机短信的默认编码方式为UCS2编码。解决办法为：通过Integer.toBinaryString(int arg0)函数（字符本质上也是一个整型数据）得到第一个字符转换的2进制字符串。然后，根据数据端的编码方式，我们将 # 编码为 1010，D 编码为1110；由于数据端发送的顺序为倒序的，当app检测到短信的一个字符转换的2进制字符串的前八位为01110101时，就可以确定这条短信是app所需读取的数据短信。</p>
<p>&emsp;&emsp;3)短信的解码<br>&emsp;&emsp;&emsp;首先要说明为什么需要对数据短信进行压缩，再解码。原因是手机的短信是以UCS2  位字符编码的，但是我们数据短信所用的字符只有0-9，#，D这12个字符，无论采用哪种编码，这都是一个极大的浪费。压缩后，可以最多一次性发送成倍的数据量。</p>
<p>&emsp;&emsp;&emsp;短信的解码涉及个步骤，包括：（1）将短信内容转化成二进制字符串，（2）判断每个二进制字符串的长度，并根据长度进行补零操作，（3）将二进制字符串翻转，（4）解码，（5）获取短信有效内容。下面分别仔细介绍每个步骤的执行过程。</p>
<p>&emsp;&emsp;&emsp;将短信内容转化成二进制字符串：<br>&emsp;&emsp;&emsp;之前已经提及，用java的库函数 Integer.toBinaryString(int arg0)可以将一个字符转换成二进制字符串。在这里，为了将整条短信的内容换成一个二进制字符串，需要先确定短信的长度，程序中调用了 String.length（）函数，然后通过一个循环语句语句，将每个字符进行一次转换。</p>
<p>&emsp;&emsp;&emsp;判断每个二进制字符串的长度，并根据长度进行补零操作：</p>
<p>&emsp;&emsp;&emsp;在这个阶段，遇到一个问题，Integer.toBinaryString(in arg0)函数获得的二进制字符串会自动把前面的0去掉，这种去掉0的二进制字符串非常不利于解码。解决办法为：先判断该二进制字符串的长度，用一个switch语句进行补零，该部分java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] chs=smsbody.toCharArray();</span><br><span class="line">String Binarysms=””;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;smsbody.length();i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (Integer.toBinaryString(chs[i]).length())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">16</span>:sms += Integer.toBinaryString(chs[i]);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">15</span>:sms += <span class="string">"0"</span>+Integer.toBinaryString(chs[i]);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">14</span>:sms += <span class="string">"00"</span>+Integer.toBinaryString(chs[i]);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">13</span>:sms += <span class="string">"000"</span>+Integer.toBinaryString(chs[i]);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>:sms += <span class="string">"0000"</span>+Integer.toBinaryString(chs[i]);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">11</span>:sms += <span class="string">"00000"</span>+Integer.toBinaryString(chs[i]);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:sms += <span class="string">"000000"</span>+Integer.toBinaryString(chs[i]);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:sms +=  <span class="string">"0000000"</span>+Integer.toBinaryString(chs[i]);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:sms +=  <span class="string">"00000000"</span>+Integer.toBinaryString(chs[i]);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:sms +=  <span class="string">"000000000"</span>+Integer.toBinaryString(chs[i]);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:sms +=  <span class="string">"0000000000"</span>+Integer.toBinaryString(chs[i]);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:sms +=  <span class="string">"00000000000"</span>+Integer.toBinaryString(chs[i]);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:sms +=  <span class="string">"000000000000"</span>+Integer.toBinaryString(chs[i]);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:sms +=  <span class="string">"0000000000000"</span>+Integer.toBinaryString(chs[i]);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:sms +=  <span class="string">"00000000000000"</span>+Integer.toBinaryString(chs[i]);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:sms +=  <span class="string">"000000000000000"</span>+Integer.toBinaryString(chs[i]);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span> :<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;&emsp;前面说过，数据发送端发送顺序是倒序的，一个二进制字符串的值为1111000011110000</p>
<p>&emsp;&emsp;&emsp;那么它正确的顺序应该是：0000111100001111，就是说需要对每8位进行一次翻转操作，程序中用StringBuffer.reverse()函数可以实现这个操作。</p>
<p>&emsp;&emsp;&emsp;接下来，便进入了解码环节，设计中，为了处理简单，我们采用的是定长编码的方式，而表示0-9，#，D只用了12个编码，剩下的四个取A、B、C、E，可以让以后有更多的拓展功能。</p>
<p>&emsp;&emsp;&emsp;具体编码如下：<br>&emsp;&emsp;&emsp;0—————-0000<br>&emsp;&emsp;&emsp;1—————-0001<br>&emsp;&emsp;&emsp;2—————-0010<br>&emsp;&emsp;&emsp;3—————-0011<br>&emsp;&emsp;&emsp;4—————-0100<br>&emsp;&emsp;&emsp;5—————-0101<br>&emsp;&emsp;&emsp;6—————-0110<br>&emsp;&emsp;&emsp;7—————-0111<br>&emsp;&emsp;&emsp;8—————-1000<br>&emsp;&emsp;&emsp;9—————-1001<br>&emsp;&emsp;&emsp;#—————-1010<br>&emsp;&emsp;&emsp;A—————-1011<br>&emsp;&emsp;&emsp;B—————-1100<br>&emsp;&emsp;&emsp;C—————-1101<br>&emsp;&emsp;&emsp;D—————-1110<br>&emsp;&emsp;&emsp;E—————-1111</p>
<p>&emsp;&emsp;&emsp;假如变量String smsBinary是经过补零和翻转处理的二进制字符串，那么下面java语句就可以完成解码工作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> boolp=<span class="number">0</span>;boolp&lt;smsBinar.length();boolp+=<span class="number">4</span>)</span><br><span class="line">	&#123;   </span><br><span class="line">		<span class="keyword">switch</span> (smsBinary.substring(boolp,boolp+<span class="number">4</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"0000"</span>:smskey += <span class="string">"0"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"0001"</span>:smskey += <span class="string">"1"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"0010"</span>:smskey += <span class="string">"2"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"0011"</span>:smskey += <span class="string">"3"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"0100"</span>:smskey += <span class="string">"4"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"0101"</span>:smskey += <span class="string">"5"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"0110"</span>:smskey += <span class="string">"6"</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"0111"</span>:smskey += <span class="string">"7"</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"1000"</span>:smskey += <span class="string">"8"</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"1001"</span>:smskey += <span class="string">"9"</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"1010"</span>:smskey += <span class="string">"#"</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"1011"</span>:smskey += <span class="string">"A"</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"1100"</span>:smskey += <span class="string">"B"</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"1101"</span>:smskey += <span class="string">"C"</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"1110"</span>:smskey += <span class="string">"D"</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"1111"</span>:smskey += <span class="string">"E"</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>: ;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;&emsp;到此解码部分全部完成。</p>
<h3 id="5-2-2-使用litepal建立数据库"><a href="#5-2-2-使用litepal建立数据库" class="headerlink" title="5.2.2 使用litepal建立数据库"></a>5.2.2 使用litepal建立数据库</h3><p>&emsp;&emsp;虽然说android本身对SQLite已经有很好地封装了，但是对于初学者来说，理解android中的原生的SQLite语句非常困难，而且十分容易出错。为此，设计中引入了另外一个包来完成数据库操作，这个专门用来完成数据库操作的包就是Litepal，使用Litepal框架来建立数据库方便使用，易于管理。当然，用litepal框架建立的数据库访问速度无法跟原生SQLite语句相比，但是满足该设计的要求还是绰绰有余。下面详细介绍litepal的配置过程，以及建表过程。</p>
<p>&emsp;&emsp;配置litepal<br>&emsp;&emsp;&emsp;1.将litepal jar包添加到libs目录。<br>&emsp;&emsp;&emsp;2.在assets目录下新建一个litepal.xml文件，设定数据库名字与版本号，并添加各个表格的映射模型。<br>&emsp;&emsp;&emsp;在本设计中，新建了TIME、DATA、SITE 3张表，于是添加了以下映射：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">litepal</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dbname</span> <span class="attr">value</span>=<span class="string">"field_data"</span>&gt;</span><span class="tag">&lt;/<span class="name">dbname</span>&gt;</span><span class="comment">&lt;!-- 数据库名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="comment">&lt;!-- 版本号 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span><span class="comment">&lt;!-- 用于设定所有的映射模型 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapping</span> <span class="attr">class</span>=<span class="string">"com.nevin.SMSlistener.TIME"</span>&gt;</span><span class="tag">&lt;/<span class="name">mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mapping</span> <span class="attr">class</span>=<span class="string">"com.nevin.SMSlistener.SITE"</span>&gt;</span><span class="tag">&lt;/<span class="name">mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mapping</span> <span class="attr">class</span>=<span class="string">"com.nevin.SMSlistener.DATA"</span>&gt;</span><span class="tag">&lt;/<span class="name">mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">litepal</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;&emsp;3.由于操作数据库时需要用到Context，而我们显然不希望在每个接口中都去传一遍这个参数，那样操作数据库就显得太繁琐了。因此，LitePal使用了一个方法来简化掉Context这个参数，只需要在AndroidManifest.xml中配置一下LitePalApplication，所有的数据库操作就都不用再传Context了，如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span> <span class="attr">android:name</span>=<span class="string">"org.litepal.LitePalApplication"</span><span class="attr">.........</span>&gt;</span></span><br><span class="line"> .........</span><br><span class="line"><span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;到此，完成了litepal的配置</p>
<p>&emsp;&emsp;建表<br>&emsp;&emsp;在这里以DATA表为例介绍建表过程。首先需要新建一个继承了DataSupport的类，并且为类导入 org.litepal.crud.DataSupport，设计中，数据发送端的发送的数据有温度、湿度、pm2.5，于是DATA表中设定了3个字段用来保存这三种数据，另外，还需要设定数据对应的时间time以及数据所对应的sim卡号码address。所以，包含id字段，DATA表中总共设定了6个字段。其中id、温度、湿度、pm2.5都是int型的，时间和号码是String型的，如图：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DATA</span> <span class="keyword">extends</span> <span class="title">DataSupport</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> String time;</span><br><span class="line">	<span class="keyword">private</span> String address;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> temperature;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> pm2_5;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> humidity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然后需要在该类中添加获取字段内容和设置字段内容的方法。<br>&emsp;&emsp;比如字段time，需要设定两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> time;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTime</span><span class="params">(String time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.time=time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;为每个字段设定了写入和获取的方法后，该表就算完成了。<br>&emsp;&emsp;另外还建立了TIME，SITE，两张表。<br>&emsp;&emsp;TIME  中有两个String 型字段，time和address。<br>&emsp;&emsp;用来记录每条数据短信的时间和号码，这个表作用就是防重复读写。<br>&emsp;&emsp;SITE 中有两个String 型字段,site,address。<br>&emsp;&emsp;让一个号码跟一个地点一一对应。实现多地点检测。<br>&emsp;&emsp;把3个表建立完成后，只需一个语句便可完成数据库的建立：<br>&emsp;&emsp;SQLiteDatabase  db = Connector.getDatabase();<br>&emsp;&emsp;到此，数据库建立完成。</p>
<h3 id="5-2-3-短信数据写入数据库与防重复读写"><a href="#5-2-3-短信数据写入数据库与防重复读写" class="headerlink" title="5.2.3 短信数据写入数据库与防重复读写"></a>5.2.3 短信数据写入数据库与防重复读写</h3><p>&emsp;&emsp;从短信中获取数据后，需要把数据写进已经建好的数据库中，这部分内容是app的核心。在这里，要先说明我们的数据格式为 ：</p>
<p>&emsp;&emsp;#D+时间+(温度数据<em>3+湿度数据</em>3+pm2.5数据<em>3)</em>hours+#</p>
<p>&emsp;&emsp;其中时间是一个10位的时间戳，我们每个小时采集温度、湿度、pm2.5数据各3个，每个的长度是3位，分别在00分、20分、40分各采集一个，hours表示缓冲的小时数，该值在下位机是可调的。</p>
<p>&emsp;&emsp;1）获取各字段的数据<br>&emsp;&emsp;&emsp;1.获取时间<br>&emsp;&emsp;&emsp;数据发送端在识别码#D会跟着一个10位数字的时间戳，用Intege.parseInt(String)函数把时间戳转换成整型数据,该数字表示的是从1970年到当时的秒数。java有专门处理时间戳的函数。只需先设定好时间的格式。<br>&emsp;&emsp;&emsp;SimpleDateFormat format = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”);<br>&emsp;&emsp;&emsp;再调用SimpleDataFormat.formata(int)函数便可以得到北京时间。<br>&emsp;&emsp;&emsp;该函数中int的值是1970年到当时的毫秒数，所以需要乘以1000；<br>&emsp;&emsp;&emsp;假如一个时间戳转换是2016.5.9 20:40:00<br>&emsp;&emsp;&emsp;经过这个格式转换后，输出是：<br>&emsp;&emsp;&emsp;2016-05-09 20:40:00<br>&emsp;&emsp;&emsp;这个时间就是下位机发送数据前从服务器获取的时间，一条短信中有可能有十几组乃至几十组数据，于是需要向后推算，每组数据向后减20分钟，得出每组数据对应的时间。由于hours的值是可调的，需要在程序中对数据长度进行分析，确定hours的值后，再得出每个数据对应的时间。另外，下位机具有发送一组即时数据的功能，所以也要对这种情况进行判断。<br>&emsp;&emsp;&emsp;得出hours的取值的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">smskeyarray=smskey.split(<span class="string">"#"</span>);   <span class="comment">//得到两个’#’号之间的有效数据</span></span><br><span class="line">	<span class="keyword">switch</span>(smskeyarray[<span class="number">1</span>].length())     <span class="comment">//根据有效数据的长度判断hours</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">20</span>: hours=<span class="string">'#'</span>;<span class="keyword">break</span>;    <span class="comment">//即时数据长度=D+时间戳（10位）+数据（3位）*3=20</span></span><br><span class="line">    	<span class="keyword">case</span> <span class="number">38</span>: hours=<span class="number">1</span>;<span class="keyword">break</span>;     	 <span class="comment">//1+10+（3+3+3）*3=38，以此类推</span></span><br><span class="line">    	<span class="keyword">case</span> <span class="number">65</span>: hours=<span class="number">2</span>;<span class="keyword">break</span>;   </span><br><span class="line">    	<span class="keyword">case</span> <span class="number">92</span>: hours=<span class="number">3</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">119</span> hours=<span class="number">4</span>;<span class="keyword">break</span>;</span><br><span class="line">    	<span class="keyword">case</span> <span class="number">146</span>: hours=<span class="number">5</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">173</span>: hours=<span class="number">6</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">200</span>: hours=<span class="number">7</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">227</span>: hours=<span class="number">8</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">254</span>: hours=<span class="number">9</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">281</span>: hours=<span class="number">10</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">308</span>: hours=<span class="number">11</span>;<span class="keyword">break</span>;    <span class="comment">//由于短信长度限制，一条短信最多能存11*3=33组数据</span></span><br><span class="line">		<span class="keyword">default</span> ： hours = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;&emsp;确认hours后，由SimpleDataFormat.formata(Ltime-1200000*i)  （20min=1200s=1200000ms），<br>&emsp;&emsp;&emsp;i是需要向后推移的次数，就可以推出每组数据对应的时间。</p>
<p>&emsp;&emsp;2）获得温度、湿度、pm2.5数据<br>&emsp;&emsp;&emsp;确认hours的值后，这一步的工作就简单多了。下面根据代码介绍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String ,temperaure=’’,humidity=’’pm2.5=’’;   </span><br><span class="line"><span class="keyword">if</span>(hours==<span class="string">'#'</span>)   <span class="comment">//即时数据</span></span><br><span class="line">	&#123;</span><br><span class="line">		temperature+=smskeyarray[<span class="number">1</span>].substring(<span class="number">11</span>, <span class="number">14</span>); </span><br><span class="line">		humidity+=smskeyarray[<span class="number">1</span>].substring(<span class="number">14</span>, <span class="number">17</span>);</span><br><span class="line">		pm2_5=smskeyarray[<span class="number">1</span>].substring(<span class="number">17</span>, <span class="number">20</span>);	</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">else</span>   <span class="comment">//用一个for循环把一条短信中的所有数据分类</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(transm=<span class="number">1</span>;transm&lt;=stall;transm++)</span><br><span class="line">	&#123;   </span><br><span class="line">	temperature+=smskeyarray[<span class="number">1</span>].substring(<span class="number">27</span>*transm-<span class="number">16</span>, <span class="number">27</span>*transm-<span class="number">7</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/*得到一个温度数据的字符串，这样处理有利于写入数据操作，将温度、湿度、Pm2.5的数据分类分别存进一个字符串变量，有利于写入数据库时的简化。*/</span></span><br><span class="line">    </span><br><span class="line">	humidity+=smskeyarray[<span class="number">1</span>].substring(<span class="number">27</span>*transm-<span class="number">7</span>, <span class="number">27</span>*transm+<span class="number">2</span>);</span><br><span class="line">	pm2_5+=smskeyarray[<span class="number">1</span>].substring(<span class="number">27</span>*transm+<span class="number">2</span>, <span class="number">27</span>*transm+<span class="number">11</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;&emsp;到此，DATA字段中还剩address 也就是sim卡号码没获得，通过下面两个语句就可以直接得到：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> smsaddressColumn = cur.getColumnIndex(<span class="string">"address"</span>);</span><br><span class="line">smsaddress = cur.getString(smsaddressColumn);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;3）将数据写进DATA表<br>&emsp;&emsp;&emsp;从短信中获得了需要的数据后，怎么把它们写进已经建好的数据库中呢，下面把DATA的写入操作写成一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writedata</span> <span class="params">(String address,String time,String temperature,String humidity,String pm2_5,<span class="keyword">int</span> hours)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(stall==<span class="string">'#'</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		DATA data=<span class="keyword">new</span> DATA();         <span class="comment">//在DATA 表中新建一行</span></span><br><span class="line">		data.setAddress(address);        <span class="comment">//设置这一行中的address字段，以此类推</span></span><br><span class="line">		data.setTime(time);</span><br><span class="line">		data.setTemperature(Integer.parseInt(temperature)); </span><br><span class="line">		data.setPm2_5(Integer.parseInt(pm2_5));</span><br><span class="line">		data.setHumidity(Integer.parseInt(humidity));</span><br><span class="line">		data.save();    <span class="comment">//写进DATA中</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;stall*<span class="number">3</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		DATA data=<span class="keyword">new</span> DATA();</span><br><span class="line">		data.setAddress(address);</span><br><span class="line">		data.setTime(time.substring(<span class="number">19</span>*i, <span class="number">19</span>*i+<span class="number">19</span>)); </span><br><span class="line">        <span class="comment">//格式"yyyy-MM-dd HH:mm:ss"共19位，向后不断地取19位</span></span><br><span class="line">		data.setTemperature(Integer.parseInt(temperature.substring(<span class="number">3</span>*i, <span class="number">3</span>*i+<span class="number">3</span>)));</span><br><span class="line">       <span class="comment">//向后取3位</span></span><br><span class="line">		data.setPm2_5(Integer.parseInt(pm2_5.substring(<span class="number">3</span>*i, <span class="number">3</span>*i+<span class="number">3</span>)));</span><br><span class="line">		data.setHumidity(Integer.parseInt(humidity.substring(<span class="number">3</span>*i, <span class="number">3</span>*i+<span class="number">3</span>)));</span><br><span class="line">		data.save();			</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;4）防重复读写</p>
<p>&emsp;&emsp;&emsp;在完成DATA表的写入后，如果下次检测到新的短信信息，app需要再次写入短信数据。这个时候，app怎么分辨出那些短信是读写过了的呢？如果不能把还没读写过的短信筛选出来，就会造成上一次的短信数据的重复写入。为了解决这个问题，想出了两个方案：</p>
<p>&emsp;&emsp;&emsp;方案一：更改短信<br>&emsp;&emsp;&emsp;在读取一条短信数据后，就马上对短信内容进行修改让短信不能解码为#D的识别码即可。<br>&emsp;&emsp;&emsp;这样需要获取修改短信的权限，在 AndroidMainifest.xml添加如下代码即可<br>&emsp;&emsp;&emsp;<uses-permission android:name="android.permission.WRITE_SMS"><br>&emsp;&emsp;&emsp;然后把解码后的#D换修改成ED,这样做可以防止短信的重复读写，而且也允许数据丢失后进行查看，到时候只需要把识别码改为ED就可以获得已经读取但是还需要访问的短信信息。<br>&emsp;&emsp;&emsp;这个解决方案无疑是最好的，访问速度最快的，但是在写app时，发现并不能成功修改短信。原因在于：<br>&emsp;&emsp;&emsp;在android 4.4后，系统禁止系统默认的短信程序以外的任何程序修改短信内容。或许也有办法能够找到android系统的漏洞，从而实现短信的修改，但是实现的难度将会大大增加。无奈之下，只好采用另外的办法。</uses-permission></p>
<p>&emsp;&emsp;&emsp;方案二：根据数据库筛选<br>&emsp;&emsp;&emsp;在每接收到一条新的数据短信后，短信的发送时间以及号码存到TIME表，然后，在每次读取短信时，先判断该短信的时间和号码已经存在于TIME表，这里也可以通过判断是否存在于DATA表，但是DATA表的内容比TIME表的内容多得多，新建一个TIME表就是为了提高访问速度。但是尽管这样，由于判断每一条短信数据是否已经被读写过了，都要访问TIME表的所有数据。这样，如果手机的数据短信数据过多的话，访问速度将会很慢。所以，需要定时的删除不再需要的短信。<br>&emsp;&emsp;&emsp;由于方案一不能实现，最后采用了方案二的办法。</p>
<p>&emsp;&emsp;5）sim卡号码与地点绑定<br>&emsp;&emsp;&emsp;对app使用者来说，一个电话号码对应着一堆温度等数据是没有任何意义的。于是，需要对sim卡人工输入一个地名进行绑定。</p>
<p>&emsp;&emsp;&emsp;实现方法为：每收到一条还没读写过的短信时，判断sim卡号码是否存在于SITE表的address字段，如果没有的话，就新建一行，把address字段设为该号码，把site字段设为“##”。这样如果app检测到SITE表的site字段存在“##”就会提示用户进入一个输入界面，把一个相应的检测地点名字设定好，然后将”##”改写为所输入的地名。这样，就可以实现sim卡号码与地名的一一绑定。有了这个功能，就可以轻易地实现多地点检测，以及处理来自于不同地点的数据。</p>
<h3 id="5-2-4-从数据库中获得数据"><a href="#5-2-4-从数据库中获得数据" class="headerlink" title="5.2.4 从数据库中获得数据"></a>5.2.4 从数据库中获得数据</h3><p>&emsp;&emsp;从数据库中读取数据，涉及到数据库的查询机制，数据库的查询机制内容非常丰富，在该app中，查询操作全部采用litepal框架中自定义的查询方法。</p>
<p>&emsp;&emsp;比如说，要获得DATA表中 电话号码为11111111111，时间为2016.5.9 23:50:00时刻的数据，可以通过下面的语句实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temperature,humidity,pm2_5;</span><br><span class="line"><span class="keyword">for</span>（<span class="keyword">int</span> cnt=<span class="number">1</span>；cnt&lt;=DataSupport.count(DATA.class)）</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(DataSupport.find(DATA.class,cnt).getTime().equals(“<span class="number">2016</span>-<span class="number">05</span>-<span class="number">09</span> <span class="number">23</span>:<span class="number">50</span>:<span class="number">00</span>”)&amp;&amp;DataSupport.find(DATA.class,cnt).getAddress().equals(“<span class="number">11111111111</span>”) )</span><br><span class="line">   	&#123;</span><br><span class="line">       	temperature = DataSupport.find(DATA.class).getTemperature();</span><br><span class="line">       	humidity= DataSupport.find(DATA.class).getHumidity();</span><br><span class="line">       	pm2_5=DataSupport.find(DATA.class).getPm2_5();</span><br><span class="line">       	<span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其中DataSupport.find(class)函数返回值是一张表中的条目数。<br>&emsp;&emsp;DataSupport.find(class,int)返回表中对应的一行。然后通过自定义的getTemperature()等函数就可以获得数据库中的温度等数据。到此，可以实现根据条件获取数据库的信息。<br>&emsp;&emsp;在该app中，支持使用者根据选定的地点，年月日查询当天的数据，用户选定时间后，就为查询数据库提供了准确的条件，从而找出相关的数据。这里涉及到两个内容：获取用户选择的地点和时间信息，将信息传给作图的activity，根据选择获得数据库数据。</p>
<p>&emsp;&emsp;获取用户选择的信息<br>&emsp;&emsp;这里涉及到app的人机交互，需要在布局文件中添加一些控件。在该activity中，设定了4个spinner控件，分别代表地点、年份、月份、日。<br>&emsp;&emsp;其中，这里的地点指的是之前和号码绑定时输入的地点名字。当检测地点有多个时，该spinner将会有多个选择。<br>&emsp;&emsp;年份，月份的设定很简单，这里就不详细介绍。而天数是根据选定的年月变化的，因此需要在选定年份或者月份的时候，更新日的选择范围。这样，就要对年份、月份的spinner设定监听。下面详细介绍对这两个spinner建立监听，从而刷新日的选择范围的过程。</p>
<p>&emsp;&emsp;1.在activiti中获取布局文件中的spinner的id:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Spinner years=(Spinner)findViewById(R.id.time_year);</span><br><span class="line">Spinner months=(Spinner)findViewById(R.id.time_month);</span><br><span class="line">Spinner days=(Spinner)findViewById(R.id.time_day);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;2.设定年月的选择项以及日的初始状态：</p>
<p>&emsp;&emsp;需要先建立一个包含所有选择项的列表，在该app中，年份的设定是2000-2016年，下面的代码就可以实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;String&gt; list_years=<span class="keyword">new</span> ArrayList&lt;String&gt;();   <span class="comment">//新建一个列表</span></span><br><span class="line">list_years=addyear(list_years);                      <span class="comment">//调用设定列表内容的函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">addyear</span><span class="params">(List&lt;String&gt; year)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> year_cnt=<span class="number">0</span>;year_cnt&lt;<span class="number">17</span>;year_cnt++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(year_cnt&lt;<span class="number">10</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				year.add(<span class="string">"200"</span>+year_cnt+<span class="string">"年"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				year.add(<span class="string">"20"</span>+year_cnt+<span class="string">"年"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> year;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;3.为该spinner建立适配器:<br>&emsp;&emsp;years.setAdapter(new ArrayAdapter<string>(this, R.layout.simple_spinner_item, list_years));<br>&emsp;&emsp;适配器有3个参数，第一个是context，第二个是spinner的布局文件，可以采用系统自带的spinner布局，该app中使用的是自定义的布局文件。第三个是List类型的变量，这里把刚才设定的代表年份的list_year添加进去。</string></p>
<p>&emsp;&emsp;4.对该spinner建立监听:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">years.setOnItemSelectedListener(<span class="keyword">new</span> OnItemSelectedListener()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemSelected</span><span class="params">(AdapterView&lt;?&gt; arg0, View arg1,<span class="keyword">int</span> arg2, <span class="keyword">long</span> arg3)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub			list_days=getdayList((String)years.getSelectedItem(),(String)years.getSelectedItem());</span></span><br><span class="line">days.setAdapter(<span class="keyword">new</span> ArrayAdapter&lt;String&gt;(Select.<span class="keyword">this</span>, R.layout.simple_spinner_item, list_days));&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNothingSelected</span><span class="params">(AdapterView&lt;?&gt; arg0)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub				</span></span><br><span class="line">	&#125;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在该函数中，onItenSelected函数就是当点击了spinner后产生的响应函数，只需在该函数中添加所要的响应。这里，可以看到响应函数中调用了一个根据年份月份获得天数的List的函数，参数中使用spinner.getSelectedItem获取选项的当前值，得到了天数的List后，再重新为天数的spinner设置适配器，这样就可以刷新天数的值。</p>
<p>&emsp;&emsp;将spinner选定的地点，年月日等数据传给作图的activity。<br>&emsp;&emsp;假如说该activity为activity1，作图的activity为activity2,就需要把site,year,month,day等数据传给activity2。<br>&emsp;&emsp;&emsp;1.设定一个button，当button按下时把数据传给activity2同时跳转到activity。button的监听跟spinner类似，这里不详细介绍。<br>&emsp;&emsp;&emsp;2.新建一个Bundle：Bundle sel_to_gra = new Bundle();<br>&emsp;&emsp;&emsp;3.为该Bundle添加数据，设定关键字（key）和值（value）：<br>&emsp;&emsp;&emsp;4.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sel_to_gra.putString(<span class="string">"sites"</span>,(String)sites.getSelectedItem());</span><br><span class="line">sel_to_gra.putString(<span class="string">"years"</span>,(String)years.getSelectedItem());</span><br><span class="line">sel_to_gra.putString(<span class="string">"months"</span>,(String)months.getSelectedItem());</span><br><span class="line">sel_to_gra.putString(<span class="string">"days"</span>,(String)days.getSelectedItem());</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;&emsp;这里，比如”sites”就是地点的关键字，在activity2可以通过这个关键字获取信息。<br>&emsp;&emsp;&emsp;5.新建一个Intent:  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Intent intent_1to2 = <span class="keyword">new</span> Intent(activity1.<span class="keyword">this</span>,activity2.class);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;&emsp;6.为该Intent添加Bundle：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intent_1to2.putExtras(sel_to_gra);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;&emsp;7.完成activity的跳转：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activity1.<span class="keyword">this</span>.startActivity(intent_1to2);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据选择获得数据库内容<br>&emsp;&emsp;作图的activity需要先接收上一个activity传过来的数据，这是一个对称的过程，需要先新建一个Bundle：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bundle gra = <span class="keyword">this</span>.getIntent().getExtras();</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;调用Bundle相关的函数通过关键字获取数据：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String sites = gra.getString(<span class="string">"sites"</span>);</span><br><span class="line">String years = gra.getString(<span class="string">"years"</span>);</span><br><span class="line">String months = gra.getString(<span class="string">"months"</span>);</span><br><span class="line">String days = gra.getString(<span class="string">"days"</span>);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;然后，通过下面一个方法就可以获得全部数据，该方法的返回值是一个字符串，该字符串包含了所有的数据内容。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">getdaydata</span><span class="params">(String input_site,String input_year,</span></span></span><br><span class="line"><span class="function"><span class="params">String input_month,String input_day)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   String address = getaddress(input_site);       <span class="comment">//根据输入的地点查找出号码</span></span><br><span class="line">   String year = getyear(input_year);    <span class="comment">//其实就是去掉2014年的年字，以此类推</span></span><br><span class="line">   String month = getmonth(input_month);</span><br><span class="line">   String day = getday(input_day);</span><br><span class="line">   String time = year+<span class="string">'-'</span>+month+<span class="string">'-'</span>+day;  <span class="comment">//拼接成一个完整的时间查找条件</span></span><br><span class="line">   String daydata=<span class="string">""</span>;</span><br><span class="line">   <span class="keyword">int</span> datachk;</span><br><span class="line">   <span class="keyword">for</span>(datachk=<span class="number">1</span>;datachk&lt;=DataSupport.count(DATA.class);datachk++)</span><br><span class="line">   &#123;</span><br><span class="line">DATA data = DataSupport.find(DATA.class, datachk); <span class="comment">//按id向下查找</span></span><br><span class="line"><span class="keyword">if</span>(time.equals(data.getTime().substring(<span class="number">0</span>,<span class="number">10</span>))&amp;&amp;address.equals(data.getSite()))      <span class="comment">//判断时间和号码是否符合</span></span><br><span class="line">&#123; </span><br><span class="line">   daydata+=data.getTime().substring(<span class="number">11</span>, <span class="number">13</span>)   <span class="comment">//读出一组数据的小时时间</span></span><br><span class="line">data.getTime().substring(<span class="number">14</span>,<span class="number">16</span>);     <span class="comment">//读出分钟数</span></span><br><span class="line">   <span class="keyword">if</span>(data.getTemperature()&gt;=<span class="number">100</span>)       <span class="comment">//数据库存的是整型数据，100就是10.0</span></span><br><span class="line">daydata+=Integer.toString(data.getTemperature());</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(data.getTemperature()&gt;=<span class="number">10</span>)      </span><br><span class="line">       daydata+=<span class="string">'0'</span>+Integer.toString(data.getTemperature());  <span class="comment">//补零操作</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	daydata+=<span class="string">"00"</span>+Integer.toString(data.getTemperature());</span><br><span class="line"><span class="keyword">if</span>(data.getHumidity()&gt;=<span class="number">100</span>)</span><br><span class="line">	daydata+=Integer.toString(data.getHumidity());</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(data.getHumidity()&gt;=<span class="number">10</span>)</span><br><span class="line">    daydata+=<span class="string">'0'</span>+Integer.toString(data.getHumidity());</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	daydata+=<span class="string">"00"</span>+Integer.toString(data.getHumidity());</span><br><span class="line"><span class="keyword">if</span>(data.getPm2_5()&gt;=<span class="number">100</span>)</span><br><span class="line">	daydata+=Integer.toString(data.getPm2_5());</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(data.getPm2_5()&gt;=<span class="number">10</span>)</span><br><span class="line">    daydata+=<span class="string">'0'</span>+Integer.toString(data.getPm2_5());</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	daydata+=<span class="string">"00"</span>+Integer.toString(data.getPm2_5());</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(daydata.length()==<span class="number">0</span>)  <span class="comment">//如果读不到数据，返回空</span></span><br><span class="line">   <span class="keyword">return</span>  “”;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   <span class="keyword">return</span> daydata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这样，就把当天的所有数据读到一个字符串变量中。</p>
<h3 id="5-2-5-利用achartengine作图"><a href="#5-2-5-利用achartengine作图" class="headerlink" title="5.2.5 利用achartengine作图"></a>5.2.5 利用achartengine作图</h3><p>&emsp;&emsp;AChartEngine是为android应用而设计的绘图工具库，能绘制折线图，饼状图，气泡图，柱形图，散点图，面积图等统计图表。<br>&emsp;&emsp;AChartEngine作每一张图都需要一个数据集（dataset）和渲染器集合（Renderer）；<br>&emsp;&emsp;AChartEngine的相关类介绍：<br>&emsp;&emsp;ChartFactory：图表生成的工厂类，通过传入的数据集和渲染器集合，即可生成Graphical View或者Graphical Activity。<br>&emsp;&emsp;XYMultipleSeriesDataset : 数据集, 其中可以封装图表所需的数据;<br>&emsp;&emsp;XYSeries : 属于 图表数据集的一部分, 每个都代表了一个数据集合 例如 折线, 一个图表中可以有多条折线, 所有的数据放在一起就是 数据集 XYMultipleSeriesDataset ;<br>&emsp;&emsp;vXYMultipleSeriesRenderer : 渲染器集合, 图表中多个曲线的渲染器;<br>&emsp;&emsp;XYSeriesRenderer : 单个曲线或单元的渲染器, 一个图表中可能有多条曲线或者柱状图等, 每个都需要一个渲染器, 所有的渲染器放在一起就是渲染器集合 。<br>&emsp;&emsp;在该app中，绘制的是数据的折线图和柱形图，因此采用的是XYSeriesRenderer，下面以折线图为例详细介绍画图的过程。<br>&emsp;&emsp;XYSeriesRenderer相关方法介绍：<br>&emsp;&emsp;创建对象 : XYSeriesRenderer r = new XYSeriesRenderer();<br>&emsp;&emsp;设置单个曲线颜色 : r.setColor(colors[i]);<br>&emsp;&emsp;设置单个曲线绘制风格 : r.setPointStyle(styles[i]);</p>
<p>&emsp;&emsp;坐标轴设置：<br>&emsp;&emsp;设置曲线标题 : setChartTitle(String tittle);<br>&emsp;&emsp;设置 x 轴标题 : setXTitle(String tittle);<br>&emsp;&emsp;设置 y 轴标题 : setYTitle(String tittle);<br>&emsp;&emsp;设置 x 轴最小值 : setXAxisMin(double);<br>&emsp;&emsp;设置 x 轴最大值 : setXAxisMax(double);<br>&emsp;&emsp;设置 y 轴最小值 : setYAxisMin(double);<br>&emsp;&emsp;设置 y 轴最大值 : setYAxisMax(double);<br>&emsp;&emsp;设置坐标轴颜色 : setAxesColor();<br>&emsp;&emsp;设置标签颜色 : setLabelsColor()；<br>&emsp;&emsp;数据准备：x轴标签，y数据。</p>
<p>&emsp;&emsp;下面以温度数据为例说明得到温度数据序列和x轴时间标签序列的过程。<br>&emsp;&emsp;由于经过之前的处理，已经得到了一个包含了所有数据的字符串变量。<br>&emsp;&emsp;该字符串中每条的数据格式为：小时（2位）、分（2位）、温度（3位）、湿度（3位）、pm2.5（3位）共13位，所以该字符串变量的长度必定是13的整数倍。<br>&emsp;&emsp;于是通过下面一个简单的方法就可以确定数据中的条目数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getdatalength</span><span class="params">(String data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(data==<span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">int</span>)(data.length()/<span class="number">13</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然后，再通过下面的方法得到数据中任何一个条目中的浮点型的温度数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">float</span> <span class="title">getftemp</span><span class="params">(String data,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;   	</span><br><span class="line">		<span class="keyword">int</span> inttemp =  Integer.parseInt(data.substring(<span class="number">13</span>*index-<span class="number">9</span>,<span class="number">13</span>*index-<span class="number">6</span>));</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">float</span>) ((<span class="keyword">float</span>)inttemp/<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;同理可以获得任何一个条目中的字符串型的时间数据，然后新建两个列表，分别用来储存x、y轴数据：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; xLabels = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">ArrayList&lt;Double&gt; values = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;再通过一个循环语句，把数据加载到列表中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(cnt= <span class="number">1</span>;cnt&lt;=datalength;cnt++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(getstime(daydata,cnt).charAt(<span class="number">2</span>)!=<span class="string">'0'</span>) <span class="comment">// 不是整点数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        xLabels.add(<span class="string">""</span>);    <span class="comment">//在x轴不设定标签，但是会在图上描点</span></span><br><span class="line">        values.add((<span class="keyword">double</span>) getftemp(daydata,cnt));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span>                        <span class="comment">//整点数据</span></span><br><span class="line">     &#123;</span><br><span class="line">        xLabels.add(daydata.substring(<span class="number">13</span>*cnt-<span class="number">13</span>, <span class="number">13</span>*cnt-<span class="number">11</span>)+<span class="string">""</span>);</span><br><span class="line">        values.add((<span class="keyword">double</span>) getftemp(daydata,cnt));</span><br><span class="line">		 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;新建一个折线图表<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LineChart tempChart = <span class="keyword">new</span> LineChart(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;填充x、y轴数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tempChart.setValuesAndLabels(values, xLabels);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;设定x、y轴标题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tempChart.setXTile(<span class="string">"时间/时"</span>);</span><br><span class="line">tempChart.setYTile(<span class="string">"湿度/%"</span>);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;设定图表标题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tempChart.setPlotTitle(sites+years+months+days+<span class="string">"湿度折线图"</span>);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;显示图表：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setContentView(tempChart);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;到这里，已经把温度折线图画出来了。画柱形图和湿度、pm2.5的图表所用方法一样，就不一一说明了。到此，app制作部分结束。</p>
<h2 id="第六章、测试方案与测试结果"><a href="#第六章、测试方案与测试结果" class="headerlink" title="第六章、测试方案与测试结果"></a>第六章、测试方案与测试结果</h2><h3 id="6-1-测试方案"><a href="#6-1-测试方案" class="headerlink" title="6.1 测试方案"></a>6.1 测试方案</h3><h4 id="6-1-1-短信压缩发送测试"><a href="#6-1-1-短信压缩发送测试" class="headerlink" title="6.1.1 短信压缩发送测试"></a>6.1.1 短信压缩发送测试</h4><p>&emsp;&emsp;压缩发送几组数据然后手机接收后进行解码，解码后与原始数据对比，测试数据完整性:<br>&emsp;&emsp;接收短信截图：</p>
<div align="center"><img src="/数据采集记录系统/figure.30.JPG" alt="图30"><br></div>

<p>&emsp;&emsp;短信解码截图：</p>
<div align="center"><img src="/数据采集记录系统/figure.31.JPG" alt="图31"><br></div>

<p>&emsp;&emsp;分析结果：<br>&emsp;&emsp;短信的压缩率为50%，通过PDU格式发送，又测试结果可知，上位手机成功的接收到了短信，并且解码后，还原出了135个字符（34*4 -1），与原码100%吻合。所以其他人的短信传输最多160个字符，我们的设备通过数据压缩，可以有效传送最多280个字符。</p>
<h4 id="6-1-2-温度测量测试"><a href="#6-1-2-温度测量测试" class="headerlink" title="6.1.2 温度测量测试"></a>6.1.2 温度测量测试</h4><p>&emsp;&emsp;使用我们的野外数据测量系统，测量一天的数据，并且使用另外的商业电子温度计测量一天的温度数据，绘制excel表格，进行对比。我们的设备是基于商业电子温度计进行标定的，前面我们也提到它的标定十分简单，现在来测试一下效果数据从早上6点开始记录：</p>
<div align="center"><img src="/数据采集记录系统/figure.32.JPG" alt="图32"><br></div>

<p>&emsp;&emsp;分析结果：<br>&emsp;&emsp;标定效果十分的好，两组数据没差多少，线性好得不得了，完美。</p>
<h4 id="6-1-3-手机APP绘图测试"><a href="#6-1-3-手机APP绘图测试" class="headerlink" title="6.1.3 手机APP绘图测试"></a>6.1.3 手机APP绘图测试</h4><p>&emsp;&emsp;将数据库的数据绘制成柱状图或折线图，观察效果：</p>
<div align="center"><img src="/数据采集记录系统/figure.33.JPG" alt="图33"><br></div>

<p>&emsp;&emsp;分析结果：<br>&emsp;&emsp;Y轴的尺度把握不够好，后期改进，总体来说效果是不错的。</p>
<h4 id="6-1-4-SD卡数据储存测试"><a href="#6-1-4-SD卡数据储存测试" class="headerlink" title="6.1.4 SD卡数据储存测试"></a>6.1.4 SD卡数据储存测试</h4><p>&emsp;&emsp;从开机开始，测量两个时间的数据，得到六组数据，查看存入SD卡的日志文件，校对数据以及记录在日志上面的设备状态。</p>
<div align="center"><img src="/数据采集记录系统/figure.34.JPG" alt="图34"><br></div>

<p>&emsp;&emsp;分析结果：<br>&emsp;&emsp;日志文件完美的记录了开机时间，并且把六组数据完整的记录了下来，系统的运行时间和短信发送次数都完整的记录了下来。</p>
<h4 id="6-1-5-GPRS连接NIST服务器获取时间测试"><a href="#6-1-5-GPRS连接NIST服务器获取时间测试" class="headerlink" title="6.1.5 GPRS连接NIST服务器获取时间测试"></a>6.1.5 GPRS连接NIST服务器获取时间测试</h4><p>&emsp;&emsp;使用系统的手动校时功能，多次联网获取一组时间，与PC端的在线网页时间对时，查看联网获得时间的准确性，联网获取了时间后通过USB发送给PC上位端，这个延时可以忽略：</p>
<div align="center"><img src="/数据采集记录系统/figure.35.JPG" alt="图35"><br></div>

<p>&emsp;&emsp;分析结果:<br>&emsp;&emsp;时间十分的准确，联网获取的时间的秒数与标准时间固定会慢6秒钟，经过排查，这6秒钟是GSM模块消耗用来检验数据并对服务器发出ACK和关闭连接的时间，这个过程固定占有6秒。6秒后，主控才把时间装载给滴答系统和发送给电脑。经过思考，这6秒不管它。</p>
<h4 id="6-1-6-九小时数据压力测试"><a href="#6-1-6-九小时数据压力测试" class="headerlink" title="6.1.6 九小时数据压力测试"></a>6.1.6 九小时数据压力测试</h4><p>&emsp;&emsp;以9小时发送一条短信的频率收集数据，一条信息包含9小时<em>3次</em>3组传感器=81个数据+一个时间信息。手机APP接收到信息后进行解析，测试大数据传输的完整性和可靠性。</p>
<div align="center"><img src="/数据采集记录系统/figure.36.JPG" alt="图36"><br></div>

<div align="center"><img src="/数据采集记录系统/figure.37.JPG" alt="图37"><br></div>

<p>&emsp;&emsp;数据完整的读取到了数据库之中，一共81个数据，包括9个小时。</p>
<p>&emsp;&emsp;分析结果：<br>&emsp;&emsp;APP画出来的折线图很好的描述出我们宿舍10点钟起床去上课，关闭空调，温度直线上升。之后吃完饭会宿舍，开空调，温度有一次下降，然后去上课，温度又回升。九小时的数据压力测速成功，十分完美，超过了题目要求的五小时频率，可以省很多短信费。</p>
<h3 id="6-2-测试结果分析"><a href="#6-2-测试结果分析" class="headerlink" title="6.2 测试结果分析"></a>6.2 测试结果分析</h3><p>&emsp;&emsp;我们的设备连续稳定运行过3天（学校断电，不然可以跑更久），所以粗略的测定设备的稳定性是OK的，同时温度湿度测量的性能也是十分OK，PM2.5的测量由于成本限制，只供参考。目前PM2.5经过粗略的测试，我们设备的PM2.5值在0-20代表空气十分良好，80-120是空气良，当数值达到150以上，空气糟糕，我们设备的PM2.5测量有很大参考意义的。</p>
<p>&emsp;&emsp;短信的压缩发送，经过测试，我们最多可以发送280个字符，压缩成70字符的PDU短信发送给手机端。手机可以快速的对数据进行解析，得到原始数据，同时有加密的作用。而经过哈夫曼编码的压缩，电脑通过USB模拟串口可以接收到压缩率在25%左右的数据，哈夫曼编码的压缩率取决与数据的字符频率，针对我们设备的数据，通过测试和统计，是有20-30%的压缩了。因为我们的数据80-98%是0-9的数字，可以达到较高的编码效率。</p>
<p>&emsp;&emsp;SD卡写入的测试很成功，我们这款STM32是不带EEPROM的（虽然有官方例程，FLASH模拟EEPROM），所以日志系统给系统运行的分析维护带来了极大的方便。经过之前的压力测试，写入速度可以达到80-130KB/S，数据无损，证明这个复杂的FAT32文件系统是可以稳定运行的。</p>
<p>&emsp;&emsp;校时测试是一直都在进行的，因为NIST的服务器并不稳定，它的服务器在国外，而中国的网络长城经常抽风，服务器会连接不上，要重试多次。很看人品，好的时候不用重试，几秒钟就获取到时间，又是后重试几次才可以。总的来说，我们设备的校时还是很可靠的。</p>
<h2 id="第七章、结束语"><a href="#第七章、结束语" class="headerlink" title="第七章、结束语"></a>第七章、结束语</h2><p>&emsp;&emsp;感谢我的队友黎殿强，我们团队两个人在比赛题目一出，就开始了整个系统的设计。站在开发一款产品的角度，我们绞尽脑汁的思考怎么让这款作品没有应付比赛题目的味道，我们一直在思考作为一款产品，使用者需要什么。一步一步完善这只设备，头一个星期就打好了板，焊出了样品，马上投入程序的开发。直到现在，我们两人学习了很多很多。就我自己而言，看了十几本的DATASHEET和DESIGN GUIDE，硬件和软件知识吸收了很多。还记得在后面的时候，设备出现了一个不可复现的BUG，串口打印完后接着显示屏打印的时候，有几率出现死机，调试了一天一夜没睡觉没吃饭，在翻看了ARM-GCC的手册才知道ARMC的格式化函数sprintf存在浮点数字节对齐的问题，官方建议就是将整数的小数分开以整数来格式化，这样我才解决了这个问题。</p>
<p>&emsp;&emsp;强哥的APP开发也是挺顺利，我们常常一起讨论APP功能的设置，APP越来越完美。看到我们的作品完成，我们真的十分开心，多日的努力有了结果，而比赛名次的那个结果也已经不重要的。</p>
<h2 id="附录1-实物图"><a href="#附录1-实物图" class="headerlink" title="附录1 实物图"></a>附录1 实物图</h2><div align="center"><img src="/数据采集记录系统/figure.38.JPG" alt="图38"><br></div>

<div align="center"><img src="/数据采集记录系统/figure.39.JPG" alt="图39"><br></div>

<h2 id="附录2-APP界面展示"><a href="#附录2-APP界面展示" class="headerlink" title="附录2 APP界面展示"></a>附录2 APP界面展示</h2><div align="center"><img src="/数据采集记录系统/figure.40.JPG" alt="图40"><br></div>

<div align="center"><img src="/数据采集记录系统/figure.41.JPG" alt="图41"><br></div>

<div align="center"><img src="/数据采集记录系统/figure.42.JPG" alt="图42"><br></div>

<div align="center"><img src="/数据采集记录系统/figure.43.JPG" alt="图43"><br></div>



                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr>

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/HerveLin" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2019 Herve Lin<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments --><!-- hexo-inject:begin --><!-- hexo-inject:end -->



</body>

</html>